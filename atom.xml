<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coder Note</title>
  
  <subtitle>coderwong&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-11T06:35:00.785Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>coderwong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CoreText点击事件处理</title>
    <link href="http://yoursite.com/2018/07/10/CoreTextTouch/"/>
    <id>http://yoursite.com/2018/07/10/CoreTextTouch/</id>
    <published>2018-07-10T03:03:49.000Z</published>
    <updated>2018-07-11T06:35:00.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇我们来讲一下点击事件，看了不少博客将图文混排、点击事件等等都放在一篇来讲，这样的话可能对于我这种小白来说有点难消化，我就将几种需求放在几篇细细道来</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>我们通过之前几篇已经可以直接进行图文混排了，这次我们需要给富文本加上点击的方法，点击回调的时候将对应的字符串、绘制范围、字符串的位置等等信息</strong></p><p>还是捋一下思路，我们的切入点还是在绘制的时候将要添加的点击事件通过自定义<code>key</code>值添加到富文本的<code>addAttributes</code>中，但是我们<code>value</code>值传入的是自定义的<code>CoreTextClickModel</code>对象，然后在绘制<code>CTRun</code>的时候识别我们的自定义<code>key</code>值，再将对应的绘制区域转为<code>NSValue</code>为<code>key</code> <code>CoreTextClickModel</code>对象为<code>value</code>放到字典里面方便遍历时候查找，然后在点击的时候使用<code>enumerateKeysAndObjectsUsingBlock</code>方法遍历字典中的<code>key</code>判断点击的区域是否在区域内然后再使用对象中的值和执行存储的<code>Block</code>，大概这样的流程，我们还是看一下代码。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="CoreTextClickModel"><a href="#CoreTextClickModel" class="headerlink" title="CoreTextClickModel"></a>CoreTextClickModel</h2><p>这个类是我们处理点击事件回调等方法的模型对象，因为图方便所以和自定义的<code>UIView</code>写在了一起，自己实现的时候可以根据需求而定，这个模型应该不难理解，主要的作用就是在点击的时候做处理的媒介。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString *const CoreTextHighLightAttributeName = @&quot;CoreTextHighLightAttributeName&quot;;</span><br><span class="line"></span><br><span class="line">typedef void(^CoreTextHighLightBlock)(NSDictionary *parameter);</span><br><span class="line"></span><br><span class="line">@interface CoreTextClickModel: NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) CoreTextHighLightBlock coreTextHighLightBlock;</span><br><span class="line">@property (nonatomic, assign) CGRect rect;</span><br><span class="line">@property (nonatomic, assign) NSRange range;</span><br><span class="line">@property (nonatomic, copy) NSString *string;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CoreTextClickModel</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="计算CTRun的绘制区域"><a href="#计算CTRun的绘制区域" class="headerlink" title="计算CTRun的绘制区域"></a>计算<code>CTRun</code>的绘制区域</h2><p>将之前的绘制图片计算<code>CTRun</code>绘制区域的方法独立拆了出来用于计算制定的<code>CTRun</code>的绘制区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (CGRect)drawWithRectangle:(CTFrameRef)frame line:(CTLineRef)line run:(CTRunRef)run point:(CGPoint)point&#123;</span><br><span class="line">    //距离顶部基线的距离</span><br><span class="line">CGFloat ascent;</span><br><span class="line">//距离底部基线的距离</span><br><span class="line">CGFloat descent;</span><br><span class="line">//进行计算的中间变量</span><br><span class="line">CGRect bounds;</span><br><span class="line">//获取图片的宽和上下基线的距离</span><br><span class="line">bounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">bounds.size.height = ascent + descent;</span><br><span class="line">//获取距离行的第一个字的原点的水平距离</span><br><span class="line">CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">//计算图片原点的x坐标</span><br><span class="line">bounds.origin.x = point.x + xOffset;</span><br><span class="line">//计算图片原点的y坐标</span><br><span class="line">bounds.origin.y = point.y - descent;</span><br><span class="line">//获取绘制的区域</span><br><span class="line">CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">//获取裁剪区域的区域</span><br><span class="line">CGRect cutRect = CGPathGetBoundingBox(path);</span><br><span class="line">//获取图片的绝对布局</span><br><span class="line">CGRect drawBounds = CGRectOffset(bounds, cutRect.origin.x, cutRect.origin.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将点击事件添加到富文本中"><a href="#将点击事件添加到富文本中" class="headerlink" title="将点击事件添加到富文本中"></a>将点击事件添加到富文本中</h2><p>如果上面的模型看懂的这个应该很好理解，就直接对处理好的富文本字符串做处理即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)setHighLight:(NSMutableAttributedString *)att range:(NSRange)range action:(CoreTextHighLightBlock)action&#123;</span><br><span class="line">    if (att.length &lt; range.location + range.length) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    CoreTextClickModel *model = [CoreTextClickModel new];</span><br><span class="line">    model.coreTextHighLightBlock = action;</span><br><span class="line">    [att addAttribute:CoreTextHighLightAttributeName value:model range:range];</span><br><span class="line">    [att addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:range];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点击事件的处理"><a href="#点击事件的处理" class="headerlink" title="点击事件的处理"></a>点击事件的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; CFArrayGetCount(lines); i++) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">for (int j = 0; j &lt; runNumber; j++) &#123;</span><br><span class="line">    CTRunRef run = CFArrayGetValueAtIndex(runs, j);</span><br><span class="line">    NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);</span><br><span class="line">    if (attributes[CoreTextHighLightAttributeName]) &#123;</span><br><span class="line">    </span><br><span class="line">        CFRange _range = CTRunGetStringRange(run);</span><br><span class="line">        NSRange range = NSMakeRange((long)_range.location, (long)_range.length);</span><br><span class="line">        CGRect rect = [self drawWithRectangle:frame line:line run:run point:point];</span><br><span class="line">        CoreTextClickModel *model = attributes[CoreTextHighLightAttributeName];</span><br><span class="line">        model.string = [att attributedSubstringFromRange:range].string;</span><br><span class="line">        model.range = range;</span><br><span class="line">        model.rect = rect;</span><br><span class="line">        NSValue *value = [NSValue valueWithCGRect:rect];</span><br><span class="line">        self.clickDic[value] = model;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要是在遍历<code>CTRun</code>的时候判断是否要添加点击事件对象，然后获取<code>CTRun</code>的绘制区域作为<code>key</code>点击事件对象为<code>value</code>添加到字典中，我们也可以使用经过优化的<code>hashMap</code>，这里面我们就先使用基本的字典对象。</p><h2 id="执行点击事件"><a href="#执行点击事件" class="headerlink" title="执行点击事件"></a>执行点击事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [super touchesBegan:touches withEvent:event];</span><br><span class="line">    UITouch * touch = [touches anyObject];</span><br><span class="line">    CGPoint location = [touch locationInView:self];</span><br><span class="line">    [self.clickDic enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        NSValue *value = key;</span><br><span class="line">        CGRect rect = [self convertRect:value.CGRectValue];</span><br><span class="line">        if (CGRectContainsPoint(rect, location)) &#123;</span><br><span class="line">            CoreTextClickModel *model = obj;</span><br><span class="line">            NSDictionary *parameter = @&#123;</span><br><span class="line">                                        @&quot;string&quot;: model.string,</span><br><span class="line">                                        @&quot;range&quot;: [NSValue valueWithRange:model.range],</span><br><span class="line">                                        @&quot;rect&quot;:[NSValue valueWithCGRect:model.rect]</span><br><span class="line">                                        &#125;;</span><br><span class="line">            model.coreTextHighLightBlock(parameter);</span><br><span class="line">            *stop = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(CGRect)convertRect:(CGRect)rect&#123;</span><br><span class="line">    return CGRectMake(rect.origin.x, self.bounds.size.height - rect.origin.y - rect.size.height, rect.size.width, rect.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的方法我们可以自己添加到自己的分类里面，因为我们在遍历<code>CTRun</code>的时候是将系统坐标放到了字典中，我们在点击事件的时候需要转化一下iOS的屏幕坐标来判断点击是否在区域内。在点击时候我们使用<code>enumerateKeysAndObjectsUsingBlock</code>方法遍历字典中的键值使用，判断转化后的坐标是否在遍历出的<code>key</code>值转换的区域内，然后取出遍历的对象来执行<code>block</code>，然后返回对象的各个参数。</p><h3 id="这种方法没有做具体的优化，可能在点击对象多的时候遍历处理的时间相对长，这个就需要依据需求来做优化了。"><a href="#这种方法没有做具体的优化，可能在点击对象多的时候遍历处理的时间相对长，这个就需要依据需求来做优化了。" class="headerlink" title="这种方法没有做具体的优化，可能在点击对象多的时候遍历处理的时间相对长，这个就需要依据需求来做优化了。"></a>这种方法没有做具体的优化，可能在点击对象多的时候遍历处理的时间相对长，这个就需要依据需求来做优化了。</h3><p><a href="https://github.com/2016321/CoreTextDemo" target="_blank" rel="noopener">Demo</a></p><p>英文水平贼渣的我又看了好久英文文档和博客总结的，如果转载请附上链接<a href="https://coderwong.com/2018/07/10/CoreTextTouch/" target="_blank" rel="noopener">https://coderwong.com/2018/07/10/CoreTextTouch/</a>，万分感谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这篇我们来讲一下点击事件，看了不少博客将图文混排、点击事件等等都放在一篇来讲，这样的话可能对于我这种小白来说有点难消化，我就将几种需求放在几篇细细道来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; clas
      
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="OC" scheme="http://yoursite.com/tags/OC/"/>
    
      <category term="Core Text" scheme="http://yoursite.com/tags/Core-Text/"/>
    
  </entry>
  
  <entry>
    <title>CoreText图文混排</title>
    <link href="http://yoursite.com/2018/07/09/CoreTextFix/"/>
    <id>http://yoursite.com/2018/07/09/CoreTextFix/</id>
    <published>2018-07-09T01:52:24.000Z</published>
    <updated>2018-07-11T03:33:07.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们接着上一篇讲，上篇已经大概的讲了下单纯的绘制文字，但是一篇文章一般都会有几张图片的，而且是嵌入文字内的，不一定是将上下文字换行来处理的，我们今天就讲一下如果图片嵌入了文字该如何处理。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>我们已经可以正常绘制富文本了，也可以通过<code>CTLine</code>和<code>CTRun</code>来分别对每行或者每行的绘制对象来进行干预来完成绘制。</strong><br>我们来简单捋一下图文混排的思路，一些准备操作和之前是一样的，只是在将富文本传递给<code>CTFramesetterRef</code>工厂对象时候需要将图片插入富文本中，因为<code>Core Text</code>无法直接绘制图片，只能是将相关的代理传递给一个既定的富文本，之后遍历<code>CTRun</code>来识别再去使用<code>Core Graphics</code>对图片进行绘制在View上面，而属性字符串里面只能存一些高度距离相关的属性。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    </span><br><span class="line">    //1.</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    //2.</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, self.bounds);</span><br><span class="line">    </span><br><span class="line">    //3.</span><br><span class="line">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);</span><br><span class="line">    CGContextTranslateCTM(context , 0, self.bounds.size.height);</span><br><span class="line">    CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">    </span><br><span class="line">    //4.1</span><br><span class="line">    NSMutableAttributedString *att = [self getAtt];</span><br><span class="line">    </span><br><span class="line">    //4.2</span><br><span class="line">    NSMutableAttributedString *attachment = [self getAttachment:(CGSizeMake(50, 50)) imageName:@&quot;SuperMary&quot;];</span><br><span class="line">    [att insertAttributedString:attachment atIndex:3];</span><br><span class="line">    </span><br><span class="line">    //5.</span><br><span class="line">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)att);</span><br><span class="line">    </span><br><span class="line">    //6.</span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, [att length]), path, NULL);</span><br><span class="line">    </span><br><span class="line">    //7.1</span><br><span class="line">    CFArrayRef lines = CTFrameGetLines(frame);</span><br><span class="line">    CFIndex lineNumber =  CFArrayGetCount(lines);</span><br><span class="line">    CGPoint lineOrigins[lineNumber];</span><br><span class="line">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), lineOrigins);</span><br><span class="line">    for (int i = 0 ; i &lt; CFArrayGetCount(lines); i++) &#123;</span><br><span class="line">        CGPoint point = lineOrigins[i];</span><br><span class="line">        CTLineRef line = CFArrayGetValueAtIndex(lines, i);</span><br><span class="line">        CGContextSetTextPosition(context, point.x, point.y);</span><br><span class="line">        CFArrayRef runs = CTLineGetGlyphRuns(line);</span><br><span class="line">        CFIndex runNumber = CFArrayGetCount(runs);</span><br><span class="line">        for (int j = 0; j &lt; runNumber; j++) &#123;</span><br><span class="line">            CTRunRef run = CFArrayGetValueAtIndex(runs, j);</span><br><span class="line">            //7.2</span><br><span class="line">            if ([self isImageAttachment:run]) &#123;</span><br><span class="line">                [self drawImage:frame line:line run:run point:point];</span><br><span class="line">            &#125;</span><br><span class="line">            CTRunDraw(run, context, CFRangeMake(0, 0));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //8.</span><br><span class="line">    CFRelease(path);</span><br><span class="line">    CFRelease(frameSetter);</span><br><span class="line">    CFRelease(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (NSMutableAttributedString *)getAtt&#123;</span><br><span class="line">    NSMutableAttributedString *att = [[NSMutableAttributedString alloc] initWithString:@&quot;Core Text, Core Text, Core Text, Core Text, Core Text, Core Text, &quot;];</span><br><span class="line">    CTFontRef font = CTFontCreateWithName(CFSTR(&quot;PingFang SC&quot;), 24, NULL);</span><br><span class="line">    [att addAttribute:(id)kCTFontAttributeName value:(__bridge id)font  range:NSMakeRange(0, att.length)];</span><br><span class="line">    long number = 10;</span><br><span class="line">    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</span><br><span class="line">    [att addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(10, 4)];</span><br><span class="line">    return att;</span><br><span class="line">&#125;</span><br><span class="line">//1.</span><br><span class="line">- (NSMutableAttributedString *)getAttachment:(CGSize)size imageName:(NSString *)imageName&#123;</span><br><span class="line">    CTRunDelegateCallbacks callBacks;</span><br><span class="line">    callBacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    callBacks.dealloc = DelegateDeallocCallback;</span><br><span class="line">    callBacks.getAscent = DelegateAscentCallBacks;</span><br><span class="line">    callBacks.getDescent = DelegateDescentCallBacks;</span><br><span class="line">    callBacks.getWidth = DelegateWidthCallBacks;</span><br><span class="line">    </span><br><span class="line">    NSString *sizeStr = NSStringFromCGSize(size);</span><br><span class="line"></span><br><span class="line">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callBacks, (__bridge void *)sizeStr);</span><br><span class="line"></span><br><span class="line">    unichar placeHolder = 0xFFFC;</span><br><span class="line">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</span><br><span class="line">    NSMutableAttributedString * imageAttachment = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</span><br><span class="line">    [imageAttachment addAttribute:@&quot;imageName&quot; value:imageName range:(NSMakeRange(0, 1))];</span><br><span class="line">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)imageAttachment, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    CFRelease(delegate);</span><br><span class="line">    </span><br><span class="line">    return imageAttachment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">void DelegateDeallocCallback (void *refCon)&#123;</span><br><span class="line">    NSLog(@&quot;dealloc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat DelegateAscentCallBacks(void * refCon)&#123;</span><br><span class="line">    CGSize size = CGSizeFromString((__bridge NSString *)refCon);</span><br><span class="line">    return size.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat DelegateDescentCallBacks(void * refCon)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat DelegateWidthCallBacks(void * refCon)&#123;</span><br><span class="line">    CGSize size = CGSizeFromString((__bridge NSString *)refCon);</span><br><span class="line">    return size.width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.</span><br><span class="line">- (BOOL)isImageAttachment:(CTRunRef)run&#123;</span><br><span class="line">    NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);</span><br><span class="line">    CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</span><br><span class="line">    NSString *sizeStr = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">    if (delegate == nil || ![sizeStr isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//4.</span><br><span class="line">- (void)drawImage:(CTFrameRef)frame line:(CTLineRef)line run:(CTRunRef)run point:(CGPoint)point&#123;</span><br><span class="line">    </span><br><span class="line">    NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);</span><br><span class="line">    NSString *imageName = attributes[@&quot;imageName&quot;];</span><br><span class="line">    if (!imageName) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    CGFloat ascent;</span><br><span class="line">    CGFloat descent;</span><br><span class="line">    CGRect boundsRun;</span><br><span class="line">    boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">    boundsRun.size.height = ascent + descent;</span><br><span class="line">    CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">    boundsRun.origin.x = point.x + xOffset;</span><br><span class="line">    boundsRun.origin.y = point.y - descent;</span><br><span class="line">    CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">    CGRect colRect = CGPathGetBoundingBox(path);</span><br><span class="line">    CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</span><br><span class="line">    </span><br><span class="line">     [self drawWithImageName:imageName rect:imageBounds];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//5.</span><br><span class="line">- (void)drawWithImageName:(NSString *)imageName rect:(CGRect)rect&#123;</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    UIImage * image = [UIImage imageNamed:imageName];</span><br><span class="line">    CGContextDrawImage(context, rect, image.CGImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>首先我们可以看到上面一段代码和之前一篇的遍历CTRun的几乎没有区别，只有 <strong>4.2</strong> 和 <strong>7.2</strong> 的部分有增添，那么我们分别讲一下这两段</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>首先我们先看一下第二段的标号为 <strong>1</strong> 的代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建一个CTRun代理回调的结构体</span><br><span class="line">CTRunDelegateCallbacks callBacks;</span><br><span class="line">//设置回调版本，kCTRunDelegateVersion1为默认</span><br><span class="line">callBacks.version = kCTRunDelegateVersion1;</span><br><span class="line">//设置当内存回收时候执行的回调</span><br><span class="line">callBacks.dealloc = DelegateDeallocCallback;</span><br><span class="line">//设置图片距离顶部基线的距离执行的回调</span><br><span class="line">callBacks.getAscent = DelegateAscentCallBacks;</span><br><span class="line">//设置图片距离底部基线的距离执行的回调</span><br><span class="line">callBacks.getDescent = DelegateDescentCallBacks;</span><br><span class="line">//设置图片的宽度执行的回调</span><br><span class="line">callBacks.getWidth = DelegateWidthCallBacks;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建代理，将参数传到代理对象中</span><br><span class="line">CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callBacks, (__bridge void *)sizeStr);</span><br><span class="line"></span><br><span class="line">//创建占位富文本，注意，不要用单空格来进行占位，会导致绘制时候图片位置计算出现问题</span><br><span class="line">unichar placeHolder = 0xFFFC;</span><br><span class="line">NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</span><br><span class="line">NSMutableAttributedString * imageAttachment = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</span><br><span class="line">//@&quot;imageName&quot;为自定义的key，将imageName传递到富文本中，在绘制的时候可以直接取用</span><br><span class="line">[imageAttachment addAttribute:@&quot;imageName&quot; value:imageName range:(NSMakeRange(0, 1))];</span><br><span class="line">//给制定范围内的富文本设置代理</span><br><span class="line">CFAttributedStringSetAttribute((CFMutableAttributedStringRef)imageAttachment, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">//释放代理对象</span><br><span class="line">CFRelease(delegate);</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>这一段就是给代理回调结构体设置的各个回调，其中返回的形参为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *sizeStr = NSStringFromCGSize(size);</span><br><span class="line">CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callBacks, (__bridge void *)sizeStr);</span><br></pre></td></tr></table></figure><p>中初始化代理时候传入的实参，因为返回时候是个指针，所以所有类型的对象都可以，也可以自定义对象进行传递。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>我们可以看到 <strong>7.2</strong> 部分调用了这个方法，这个方法的作用就是判断遍历出来的 <code>CTRun</code> 是否是自己要绘制的富文本，返回一个布尔值。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>方法的前面的判断就是判断是否有imageName，我们也可以根据需求将一个默认图绘制上去，我们着重讲一下计算图片绝对布局的算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//距离顶部基线的距离</span><br><span class="line">CGFloat ascent;</span><br><span class="line">//距离底部基线的距离</span><br><span class="line">CGFloat descent;</span><br><span class="line">//进行计算的中间变量</span><br><span class="line">CGRect bounds;</span><br><span class="line">//获取图片的宽和上下基线的距离</span><br><span class="line">bounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">bounds.size.height = ascent + descent;</span><br><span class="line">//获取距离行的第一个字的原点的水平距离</span><br><span class="line">CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">//计算图片原点的x坐标</span><br><span class="line">bounds.origin.x = point.x + xOffset;</span><br><span class="line">//计算图片原点的y坐标</span><br><span class="line">bounds.origin.y = point.y - descent;</span><br><span class="line">//获取绘制的区域</span><br><span class="line">CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">//获取裁剪区域的区域</span><br><span class="line">CGRect cutRect = CGPathGetBoundingBox(path);</span><br><span class="line">//获取图片的绝对布局</span><br><span class="line">CGRect drawBounds = CGRectOffset(bounds, cutRect.origin.x, cutRect.origin.y);</span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>两个形参分别是需要绘制的图片和图片的绝对布局，我们直接绘制既可。</p><hr><h5 id="我将图文混排增加的代码直接写成了各个方法，更灵活更易懂，这个地方我们可以自定义一个类来专门处理图文相关的代理等一系列的参数，YYText就是自定义了一个YYTextRunDelegate这个类来处理相关的，下一篇我们将继续写点击事件相关"><a href="#我将图文混排增加的代码直接写成了各个方法，更灵活更易懂，这个地方我们可以自定义一个类来专门处理图文相关的代理等一系列的参数，YYText就是自定义了一个YYTextRunDelegate这个类来处理相关的，下一篇我们将继续写点击事件相关" class="headerlink" title="我将图文混排增加的代码直接写成了各个方法，更灵活更易懂，这个地方我们可以自定义一个类来专门处理图文相关的代理等一系列的参数，YYText就是自定义了一个YYTextRunDelegate这个类来处理相关的，下一篇我们将继续写点击事件相关"></a>我将图文混排增加的代码直接写成了各个方法，更灵活更易懂，这个地方我们可以自定义一个类来专门处理图文相关的代理等一系列的参数，<code>YYText</code>就是自定义了一个<code>YYTextRunDelegate</code>这个类来处理相关的，下一篇我们将继续写点击事件相关</h5><p><a href="https://github.com/2016321/CoreTextDemo" target="_blank" rel="noopener">Demo</a></p><p>英文水平贼渣的我又看了好久英文文档和博客总结的，如果转载请附上链接<a href="https://coderwong.com/2018/07/09/CoreTextFix/" target="_blank" rel="noopener">https://coderwong.com/2018/07/09/CoreTextFix/</a>，万分感谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们接着上一篇讲，上篇已经大概的讲了下单纯的绘制文字，但是一篇文章一般都会有几张图片的，而且是嵌入文字内的，不一定是将上下文字换行来处理的，我们今天就讲一下如果图片嵌入了文字该如何处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;思路&quot;&gt;
      
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="OC" scheme="http://yoursite.com/tags/OC/"/>
    
      <category term="Core Text" scheme="http://yoursite.com/tags/Core-Text/"/>
    
  </entry>
  
  <entry>
    <title>CoreText跳坑</title>
    <link href="http://yoursite.com/2018/07/05/CoreText/"/>
    <id>http://yoursite.com/2018/07/05/CoreText/</id>
    <published>2018-07-05T12:54:26.000Z</published>
    <updated>2018-07-11T03:32:48.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记得上次更新是半年前了，转眼就到了18年的Q3了。回顾一下我的博客的空窗期，记得在年初的时候前东家孵化了个线上的视频约见的项目，自己也算是尽力在做。之后又对项目管理感兴趣学了些报了个项目管理的考试，然而在最后一门论文崩盘也是心塞。在工作学习中发现，自己接触的越多越会感觉到自己的渺小自己的不足，同时考完试之后跳了一家更大的公司也搬了家，在项目组里面默默无闻，尽力去做的更好去完善自己吧，咳咳，扯多了，作为回归的第一篇还是得有点质量，总结一下CoreText的相关的东西，尽量用最少的文字讲更多的东西</p></blockquote><a id="more"></a><h1 id="Core-Text"><a href="#Core-Text" class="headerlink" title="Core Text"></a>Core Text</h1><h2 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h2><p>Core Text提供了一个底层的编程接口，用于文本的布局和处理字体。Core Text布局引擎旨在实现高性能，易用性以及与Core Foundation的紧密集成。文本布局API提供高质量的排版，包括字符到字形的转换，带有连字，字距调整等。互补的Core Text字体技术提供自动字体替换，字体描述符和集合，轻松访问字体度量和字形数据以及许多其他功能。</p><p>多线程中的注意事项：Core Text中的所有单个函数都是线程安全的。字体对象（<strong>CTFont</strong>，<strong>CTFontDescriptor</strong>和相关的对象）可以被多个任务、队列或线程同时使用。但是，布局对象（<strong>CTTypesetter</strong>，<strong>CTFramesetter</strong>，<strong>CTRun</strong>，<strong>CTLine</strong>，<strong>CTFrame</strong>和关联对象）应该在单个操作，工作队列或线程中使用。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><span id="1-2-1"></span></p><h3 id="坐标系相关"><a href="#坐标系相关" class="headerlink" title="坐标系相关"></a>坐标系相关</h3><p>我们如果不做任何转换的话我们应该绘制的是这个样子的</p><p><img src="https://s6.postimg.cc/81bu1h1zl/Simulator_Screen_Shot_-_i_Phone_X_-_2018-07-06_at_09.43.59.png" alt=""></p><p>可能图有点小，大致就是y轴反向的样子，因为<code>Core Text</code>期初是<code>OS X</code>系统上面的底层库，y轴为向上的方向，原点坐标是在左下，而<code>iOS</code>的原点坐标是在左上角的，y轴正好是反方向</p><h3 id="Core-Text相关概念"><a href="#Core-Text相关概念" class="headerlink" title="Core Text相关概念"></a>Core Text相关概念</h3><p>今天我们尽量不去涉及<strong>Text Kit</strong>相关的东西，我们只是借用一下图，<strong>Text Kit</strong>是对<strong>Core Text</strong>的更高级的封装。</p><p><img src="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png" alt=""></p><p>如下图我们可以了解到<strong>Core Text</strong>的形成层次结构，最上层的是<code>CTFramesetter</code>工厂对象<code>CTFramesetterRef</code>可以理解为负责一个区域的图文绘制的对象，随后这个工厂对象会根据属性字符串去调用<code>CTTypesetter</code>对象去做排版相关的操作，同时根据属性字符串<code>CTFramesetter</code>对象生成若干<code>CTFrame</code>段落对象，每个段落对象又生成若干的<code>CTLine</code>对象可以理解为每个段落中的行的对象，最后每个<code>CTLine</code>行对象中又生成若干<code>CTRun</code>字形运行时对象，每个对象里面的每个字形都有相同的属性，比如一行6个字里面<code>cccccc</code>，每个字母都不一样的颜色那这个<code>CTLine</code>对象就有6个<code>CTRun</code>对象</p><p><img src="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Art/core_text_arch_2x.png" alt=""></p><p><a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html" target="_blank" rel="noopener">可以看相关的文档做更深入了解</a></p><p><a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Overview/Overview.html" target="_blank" rel="noopener">还有这里</a></p><h2 id="基本Class"><a href="#基本Class" class="headerlink" title="基本Class"></a>基本Class</h2><h3 id="CTFont"><a href="#CTFont" class="headerlink" title="CTFont"></a>CTFont</h3><p><code>CTFont</code>用来表示<code>Core Text</code>字体对象。字体对象表示应用程序的字体，<code>CTFont</code>提供对字体描述的访问，例如磅值，变换矩阵属性和其他属性。字体提供了相对于彼此布置字形的帮助，并用于在图形上下文中绘制时设置字体。</p><h3 id="CTFontCollection"><a href="#CTFontCollection" class="headerlink" title="CTFontCollection"></a>CTFontCollection</h3><p><code>CTFontCollection</code>用来表示字体描述对象集合，即一组字体合成的单个对象。</p><h3 id="CTFontDescriptor"><a href="#CTFontDescriptor" class="headerlink" title="CTFontDescriptor"></a>CTFontDescriptor</h3><p><code>CTFontDescriptor</code>用来表示字体描述对象，可以指定字体的属性字典（例如名称，磅值和变体）。</p><h3 id="CTFrame"><a href="#CTFrame" class="headerlink" title="CTFrame"></a>CTFrame</h3><p><code>CTFrame</code>用来表示包含多行文本的框架。帧对象是由框架集对象执行的文本框架处理产生的输出。</p><h3 id="CTFramesetter"><a href="#CTFramesetter" class="headerlink" title="CTFramesetter"></a>CTFramesetter</h3><p><code>CTFramesetter</code>类型用于生成CTFrame对象。CTFramesetter是CTFrame对象的对象工厂。</p><h3 id="CTGlyphInfo"><a href="#CTGlyphInfo" class="headerlink" title="CTGlyphInfo"></a>CTGlyphInfo</h3><p><code>CTGlyphInfo</code>类型让你可以覆盖字体从Unicode到字形ID的指定映射。</p><h3 id="CTLine"><a href="#CTLine" class="headerlink" title="CTLine"></a>CTLine</h3><p><code>CTLine</code>用来表示一行文本。</p><h3 id="CTParagraphStyle"><a href="#CTParagraphStyle" class="headerlink" title="CTParagraphStyle"></a>CTParagraphStyle</h3><p><code>CTParagraphStyle</code>用来表示属性字符串中的段落或标尺属性对象。</p><h3 id="CTRun"><a href="#CTRun" class="headerlink" title="CTRun"></a>CTRun</h3><p><code>CTRun</code>用来表示字形运行，它是一组拥有相同属性和方向的连续字形。</p><h3 id="CTRunDelegate"><a href="#CTRunDelegate" class="headerlink" title="CTRunDelegate"></a>CTRunDelegate</h3><p><code>CTRunDelegate</code>用来表示一个运行代理，其被分配到一个运行（属性范围），以控制印刷性状例如字的向上偏移量，字的向下偏移量，和字宽。</p><h3 id="CTTextTab"><a href="#CTTextTab" class="headerlink" title="CTTextTab"></a>CTTextTab</h3><p><code>CTTextTab</code>用来表示段落样式中的选项卡，存储对齐类型和位置。</p><h3 id="CTTypesetter"><a href="#CTTypesetter" class="headerlink" title="CTTypesetter"></a>CTTypesetter</h3><p><code>CTTypesetter</code>用来表示排版器，它执行行布局。</p><p><a href="https://developer.apple.com/documentation/coretext?language=objc" target="_blank" rel="noopener">查看详细文档</a></p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="简单的绘制文字"><a href="#简单的绘制文字" class="headerlink" title="简单的绘制文字"></a>简单的绘制文字</h2><p>因为<code>Core Text</code>底层是使用<code>Core Graphics</code>来绘制的，我们要在<code>UIView</code>的<code>drawRect</code>中写相关的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">CGPathAddRect(path , NULL , self.bounds);</span><br><span class="line"></span><br><span class="line">//3</span><br><span class="line">CGContextSetTextMatrix(context, CGAffineTransformIdentity);</span><br><span class="line">CGContextTranslateCTM(context , 0, self.bounds.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line"></span><br><span class="line">//4.</span><br><span class="line">NSAttributedString *att = ...;</span><br><span class="line"></span><br><span class="line">//5.</span><br><span class="line">CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)att);</span><br><span class="line"></span><br><span class="line">//6.</span><br><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, [att length]), path , NULL);</span><br><span class="line"></span><br><span class="line">//7.1</span><br><span class="line">CTFrameDraw(frame, context);</span><br><span class="line">//7.2</span><br><span class="line">CFArrayRef lines = CTFrameGetLines(frame);</span><br><span class="line">CFIndex lineNumber =  CFArrayGetCount(lines);</span><br><span class="line">CGPoint lineOrigins[lineNumber];</span><br><span class="line">CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), lineOrigins);</span><br><span class="line">for (int i = 0 ; i &lt; lineNumber; i++) &#123;</span><br><span class="line">CTLineRef line = CFArrayGetValueAtIndex(lines, i);</span><br><span class="line">CGContextSetTextPosition(context, lineOrigins[i].x, lineOrigins[i].y);</span><br><span class="line">CTLineDraw(line , context);</span><br><span class="line">&#125;</span><br><span class="line">//7.3</span><br><span class="line">CFArrayRef lines = CTFrameGetLines(frame);</span><br><span class="line">CFIndex lineNumber =  CFArrayGetCount(lines);</span><br><span class="line">CGPoint lineOrigins[lineNumber];</span><br><span class="line">CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), lineOrigins);</span><br><span class="line">for (int i = 0 ; i &lt; CFArrayGetCount(lines); i++) &#123;</span><br><span class="line">CTLineRef line = CFArrayGetValueAtIndex(lines, i);</span><br><span class="line">CGContextSetTextPosition(context, lineOrigins[i].x, lineOrigins[i].y);</span><br><span class="line">CFArrayRef runs = CTLineGetGlyphRuns(line);</span><br><span class="line">CFIndex runNumber = CFArrayGetCount(runs);</span><br><span class="line">for (int j = 0; j &lt; runNumber; j++) &#123;</span><br><span class="line">CTRunRef run = CFArrayGetValueAtIndex(runs, j);</span><br><span class="line">CTRunDraw(run, context, CFRangeMake(0, 0));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//8</span><br><span class="line">CFRelease(path);</span><br><span class="line">CFRelease(framesetter);</span><br><span class="line">CFRelease(frame);</span><br></pre></td></tr></table></figure><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>应该不用过多的解释，就是因为<code>drawRect</code>方法内部是由<code>Core Graphics</code>来做绘制任务的，再次可以取到当前绘制的上下文对象<code>CGContextRef</code>。虽然在其他的地方可以自己去创建<code>CGContextRef</code>上下文对象，然后自己去绘制，然后再释放，但系统在<code>drawRect</code>绘制方法的时候会压栈进去一个系统创建的<code>CGContextRef</code>上下文对象，我们为什么不去用呢，毕竟写<code>Core Graphics</code>的代码也是很刺激，如果动态性很强建议不要在<code>drawRect</code>中重写相关的代码，因为一旦重写了这个方法系统会自动给你分配一块内存去做绘制任务，大家可以使用断点打印一下<code>self.layer.contents</code>，当没有实现<code>drawRect</code>方法的时候是<code>nil</code></p><p><strong>咳咳，跑题了，大家可以看下面两个博客简单了解一下</strong></p><p><a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕上</a></p><p><a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="noopener">内存恶鬼drawRect(其实也不至于题目说的那么严重…)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>这里我们可以对绘制区域做更细化的限制，如果<code>Core Graphcis</code>用着不习惯就用<code>UIBezierPath</code>来限制绘制区域吧，请注意这里面使用的仍然是系统坐标，如果需要绘制被排除的区域，需要使用系统坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//初始化绘制的区域</span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">//绘制形状限制为矩形</span><br><span class="line">CGPathAddRect(path , NULL , self.bounds);</span><br></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>坐标系相关概念如果还不是很理解可以去前面再看一下</p><p><a href="#1-2-1" target="_self">灰机票</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//设置字形的变换矩阵不做图形变换</span><br><span class="line">CGContextSetTextMatrix(context, CGAffineTransformIdentity);</span><br><span class="line">//将画布向上平移相应的高度</span><br><span class="line">CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">//x轴缩放系数为1，y轴缩放系数为-1，以x轴为轴旋转180度</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>不解释</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//初始化framesetter工厂对象</span><br><span class="line">CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)att);</span><br></pre></td></tr></table></figure><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>这也有多种写法，如果喜欢用<code>UIBezierPath</code>也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, [att length]), path , NULL);</span><br></pre></td></tr></table></figure><p>我们可以将 <strong>2</strong> 和 <strong>6</strong> 这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath * path = [UIBezierPath bezierPathWithRect:self.bounds];</span><br><span class="line">//注意，这里面使用的系统坐标</span><br><span class="line">UIBezierPath * cirlePath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 200, 100, 100)];</span><br><span class="line">[path appendPath:cirlePath];</span><br><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, [att length]), path.CGPath, NULL);</span><br></pre></td></tr></table></figure><h3 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h3><p>这个时候绘制区域对象已经准备好了，如果没有其他操作的话就可以直接绘制到<code>self.layer</code>上面了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTFrameDraw(frame, context);</span><br></pre></td></tr></table></figure><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><p>但是有的时候我们需要对不同的行做操作，这个时候我们就要对CTLine分别做绘制了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//获取CTLine数组</span><br><span class="line">CFArrayRef lines = CTFrameGetLines(frame);</span><br><span class="line">//获取CTLine对象数量</span><br><span class="line">CFIndex lineNumber =  CFArrayGetCount(lines);</span><br><span class="line">//初始化行原点数组</span><br><span class="line">CGPoint lineOrigins[lineNumber];</span><br><span class="line">//获取每行的原点</span><br><span class="line">CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), lineOrigins);</span><br><span class="line">for (int i = 0 ; i &lt; lineNumber; i++) &#123;</span><br><span class="line">//获取行对象</span><br><span class="line">CTLineRef line = CFArrayGetValueAtIndex(lines, i);</span><br><span class="line">//设置行的绘制的原点</span><br><span class="line">CGContextSetTextPosition(context, lineOrigins[i].x, lineOrigins[i].y);</span><br><span class="line">//绘制一行的内容</span><br><span class="line">CTLineDraw(line , context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h3><p>同时我们有的时候要对每行的<code>CTRun</code>对象做不同的操作</p><p>我们将<strong>7.2</strong>的最后的操作换成下面的代码就是遍历每行的<code>CTRun</code>进行绘制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFArrayRef runs = CTLineGetGlyphRuns(line);</span><br><span class="line">for (int j = 0; j &lt; CFArrayGetCount(runs); j++) &#123;</span><br><span class="line">CTRunRef run = CFArrayGetValueAtIndex(runs, j);</span><br><span class="line">CTRunDraw(run, context, CFRangeMake(0, 0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>值得一提的就是，之前向系统申请的<code>Context</code>不需要释放，系统会在恰当的时机去释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(path);</span><br><span class="line">CFRelease(framesetter);</span><br><span class="line">CFRelease(frame);</span><br></pre></td></tr></table></figure><h3 id="简单介绍一下概念，具体项目中可以用到的功能持续更新"><a href="#简单介绍一下概念，具体项目中可以用到的功能持续更新" class="headerlink" title="简单介绍一下概念，具体项目中可以用到的功能持续更新~"></a>简单介绍一下概念，具体项目中可以用到的功能持续更新~</h3><p>随后我们会讲到图文混排、文字点击回调、文字点击高亮等相关操作</p><p><a href="https://github.com/2016321/CoreTextDemo" target="_blank" rel="noopener">Demo</a></p><p>英文水平贼渣的我看了好久英文文档和博客总结的，如果转载请附上链接<a href="https://coderwong.com/2018/07/05/CoreText/" target="_blank" rel="noopener">https://coderwong.com/2018/07/05/CoreText/</a>，万分感谢</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记得上次更新是半年前了，转眼就到了18年的Q3了。回顾一下我的博客的空窗期，记得在年初的时候前东家孵化了个线上的视频约见的项目，自己也算是尽力在做。之后又对项目管理感兴趣学了些报了个项目管理的考试，然而在最后一门论文崩盘也是心塞。在工作学习中发现，自己接触的越多越会感觉到自己的渺小自己的不足，同时考完试之后跳了一家更大的公司也搬了家，在项目组里面默默无闻，尽力去做的更好去完善自己吧，咳咳，扯多了，作为回归的第一篇还是得有点质量，总结一下CoreText的相关的东西，尽量用最少的文字讲更多的东西&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="OC" scheme="http://yoursite.com/tags/OC/"/>
    
      <category term="Core Text" scheme="http://yoursite.com/tags/Core-Text/"/>
    
  </entry>
  
  <entry>
    <title>Swift原生与RN通信的实现</title>
    <link href="http://yoursite.com/2017/12/19/Swift%E5%8E%9F%E7%94%9F%E4%B8%8ERN%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/12/19/Swift原生与RN通信的实现/</id>
    <published>2017-12-19T05:17:51.000Z</published>
    <updated>2018-07-02T10:41:30.479Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公司的工程是使用纯Swift开发的，正好我们最近的版本需要使用RN进行混编，官网不是很友好用的都是OC来实现的，这里我们用Swift来与RN进行通信，下面我们简单介绍，前提是您已经将RN集成到工程中，如果不知道怎么集成的可以查看<a href="reactnative.com">官网</a>或者<a href="reactnative.cn">中文网</a></p><p>环境:Xcode9、Swift4.0</p></blockquote><a id="more"></a><h3 id="RN调用iOS原生的方法"><a href="#RN调用iOS原生的方法" class="headerlink" title="RN调用iOS原生的方法"></a>RN调用iOS原生的方法</h3><p><code>RNTestManagerBridge.h</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">@interface RNTestManagerBridge : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>RNTestManagerBridge.m</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;RNTestManagerBridge.h&quot;</span><br><span class="line">@implementation RNTestManagerBridge</span><br><span class="line">RCT_EXPORT_MODULE(bingo);</span><br><span class="line">RCT_EXPORT_METHOD(test)&#123;</span><br><span class="line">    NSLog(@&quot;test------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>上面的<code>bingo</code>是自定义的模块名字，如果不填写默认为类名<br>在RN中调用，需要引用对应名字的桥接模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var TestBridgeMoudle = NativeModules.bingo;</span><br><span class="line">TestBridgeMoudle.test();</span><br></pre></td></tr></table></figure><p>官方是使用宏定义<code>RCT_EXPORT_METHOD</code>将调用的原生方法声明，我们都知道Swift无法使用宏定义，所以我们需要让OC的桥接类在中间桥接Swift和RN。</p><h3 id="我们使用Swift来写桥接类"><a href="#我们使用Swift来写桥接类" class="headerlink" title="我们使用Swift来写桥接类"></a>我们使用Swift来写桥接类</h3><p>先新建一个<code>RNTestManagerBridge.swift</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">@objc(BridgeManager)</span><br><span class="line">open class BridgeManager: NSObject &#123;</span><br><span class="line">    @objc(test:)</span><br><span class="line">    func test(str : String) -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这种写法也是可以的，因为OC中的方法调用是自动隐去了首个变量名，在使用<code>@objc</code>注册方法的时候如果方法的首个变量不使用<code>_</code>隐去的话，与<code>RCT_EXTERN_METHOD</code>注册的的方法无法对应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">@objc(BridgeManager)</span><br><span class="line">open class BridgeManager: NSObject &#123;</span><br><span class="line">    @objc func test(_ str : String) -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，创建一个私有的实现文件，并将必要的信息注册到RN中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line"></span><br><span class="line">@interface RCT_EXTERN_MODULE(BridgeManager, NSObject)</span><br><span class="line">RCT_EXTERN_METHOD(test:(NSString *)str)</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>需要一个额外的桥接头文件，用来导出Objective-C文件给Swift。如果你是通过Xcode菜单中的File&gt;New File来创建的Swift文件，Xcode会自动为你创建这个头文件。在这个头文件中，你需要引入RCTBridgeModule.h。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br></pre></td></tr></table></figure><p>同样的，你也可以使用<code>RCT_EXTERN_REMAP_MODULE</code>和<code>RCT_EXTERN_REMAP_METHOD</code>来改变导出模块和方法的JavaScript调用名称。 了解更多信息，请参阅<a href="https://github.com/facebook/react-native/blob/master/React/Base/RCTBridgeModule.h" target="_blank" rel="noopener">RCTBridgeModule</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;公司的工程是使用纯Swift开发的，正好我们最近的版本需要使用RN进行混编，官网不是很友好用的都是OC来实现的，这里我们用Swift来与RN进行通信，下面我们简单介绍，前提是您已经将RN集成到工程中，如果不知道怎么集成的可以查看&lt;a href=&quot;reactnative.com&quot;&gt;官网&lt;/a&gt;或者&lt;a href=&quot;reactnative.cn&quot;&gt;中文网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境:Xcode9、Swift4.0&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>使用LeanCloud对Hexo构建的博客配置统计功能</title>
    <link href="http://yoursite.com/2017/12/18/%E4%BD%BF%E7%94%A8LeanCloud%E5%AF%B9Hexo%E6%9E%84%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2017/12/18/使用LeanCloud对Hexo构建的博客配置统计功能/</id>
    <published>2017-12-18T06:43:38.000Z</published>
    <updated>2018-07-09T04:33:57.515Z</updated>
    
    <content type="html"><![CDATA[<p>##重大更新<br>由于NexT主题使用的Leancloud访客统计插件存在重大安全漏洞，拥有不良企图的人利用该漏洞可随意更改访客数量或一定程度上增删数据库记录。请根据下面的链接对其做相应的修改。</p><p><a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">https://leaferx.online/2018/02/11/lc-security/</a></p><h4 id="最近使用的hexo-NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题"><a href="#最近使用的hexo-NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题" class="headerlink" title="最近使用的hexo+NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题"></a>最近使用的hexo+NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题</h4><a id="more"></a><h4 id="配置LeanCloud"><a href="#配置LeanCloud" class="headerlink" title="配置LeanCloud"></a>配置<a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a></h4><p>之前使用LeanCloud进行移动端网络数据库的配置和开发，在配置博客的过程中发现hexo可以使用它来进行阅读统计，下面跟着我来进行配置。前提是您已经有Leancloud的账号。</p><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><ul><li>首先我们先新建一个应用专门进行博客的访问统计，首先打开控制台创建应用:<br><img src="https://s6.postimg.cc/4qhhvay8x/2353844-3efede1f3c9fc04e.png" alt=""></li><li>点击进入创建的应用<br><img src="https://s6.postimg.cc/jz7f937cx/2353844-56f13caefe730533.png" alt=""></li><li>创建一个类<br><img src="https://s6.postimg.cc/i7ege6vpt/2353844-b9e180def259dca0.png" alt=""></li><li>点击创建Class之后，但是为了保证我们前面对NexT主题的修改兼容，<strong>此处的新建Class名字必须为Counter</strong>:</li><li>由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择<strong>无限制</strong><br><img src="https://s6.postimg.cc/aensm7ab5/2353844-bae6e955d08be02a.png" alt=""></li><li>选择左侧的应用Key选项，即可发现我们创建应用的AppID以及AppKey，有了它，我们就有权限能够通过主题中配置好的Javascript代码与这个应用的Counter表进行数据存取操作了:<br><img src="https://s6.postimg.cc/hun280l5t/2353844-faa0f67a1cae51fb.png" alt=""></li><li>复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: &lt;#app_id#&gt;</span><br><span class="line">  app_key: &lt;#app_key#&gt;</span><br></pre></td></tr></table></figure><p>这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。</p><h4 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h4><p>当你配置部分完成之后，初始的文章统计量显示为0，但是这个时候我们LeanCloud对应的应用的<code>Counter</code>表中并没有相应的记录，只是单纯的显示为0而已，当博客文章在配置好阅读量统计服务之后第一次打开时，便会自动向服务器发送数据来创建一条数据，该数据会被记录在对应的应用的<code>Counter</code>表中。</p><p><img src="https://s6.postimg.cc/i7ege7yap/2353844-b7b638b70971d728.png" alt=""></p><p>我们可以修改其中的<code>time</code>字段的数值来达到修改某一篇文章的访问量的目的（博客文章访问量快递提升人气的装逼利器）。双击具体的数值，修改之后回车即可保存。</p><ul><li><code>url</code>字段被当作唯一ID来使用，因此如果你不知道带来的后果的话请不要修改。</li><li><code>title</code>字段显示的是博客文章的标题，用于后台管理的时候区分文章之用，没有什么实际作用。</li><li>其他字段皆为自动生成，具体作用请查阅LeanCloud官方文档，如果你不知道有什么作用请不要随意修改。</li></ul><h4 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h4><p>因为AppID以及AppKey是暴露在外的，因此如果一些别用用心之人知道了之后用于其它目的是得不偿失的，为了确保只用于我们自己的博客，建议开启Web安全选项，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。</p><p>选择应用的设置的<code>安全中心</code>选项卡:<br><img src="https://s6.postimg.cc/z7xcmwj1t/2353844-b7b638b70971d728-1.png" alt=""></p><p>在<code>Web 安全域名</code>中填入我们自己的博客域名，来确保数据调用的安全:<br><img src="https://s6.postimg.cc/xsvry62j5/broswer_403.png" alt=""></p><p>如果你不知道怎么填写安全域名而或者填写完成之后发现博客文章访问量显示不正常，打开浏览器调试模式，发现如下图的输出:</p><p><img src="https://s6.postimg.cc/rf6ouwpxd/open_safe_center.png" alt=""></p><p>这说明你的安全域名填写错误，导致服务器拒绝了数据交互的请求，你可以更改为正确的安全域名或者你不知道如何修改请在本博文中留言或者放弃设置Web安全域名。</p><blockquote><p>本文作者： 夏末<br>本文链接： <a href="https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html" target="_blank" rel="noopener">https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html</a><br>版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##重大更新&lt;br&gt;由于NexT主题使用的Leancloud访客统计插件存在重大安全漏洞，拥有不良企图的人利用该漏洞可随意更改访客数量或一定程度上增删数据库记录。请根据下面的链接对其做相应的修改。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leaferx.online/2018/02/11/lc-security/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leaferx.online/2018/02/11/lc-security/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;最近使用的hexo-NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题&quot;&gt;&lt;a href=&quot;#最近使用的hexo-NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题&quot; class=&quot;headerlink&quot; title=&quot;最近使用的hexo+NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题&quot;&gt;&lt;/a&gt;最近使用的hexo+NexT搭建博客，在搭建的过程中有各种问题，之后会一一列出，这篇文章先讲一下阅读统计的相关问题&lt;/h4&gt;
    
    </summary>
    
      <category term="Front-End" scheme="http://yoursite.com/categories/Front-End/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Method Dispatch in Swift</title>
    <link href="http://yoursite.com/2017/12/07/Method-Dispatch-in-Swift/"/>
    <id>http://yoursite.com/2017/12/07/Method-Dispatch-in-Swift/</id>
    <published>2017-12-07T07:35:23.000Z</published>
    <updated>2018-07-02T10:42:22.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><h3 id="已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了-zhuang-解-bi-一下。"><a href="#已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了-zhuang-解-bi-一下。" class="headerlink" title="已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了(zhuang)解(bi)一下。"></a>已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了(zhuang)解(bi)一下。</h3><a id="more"></a><p><img src="https://s6.postimg.cc/hun285imp/2353844-722dae5ad4a83c90.gif" alt="开始装逼"></p><h3 id="滑腻腻的分割线"><a href="#滑腻腻的分割线" class="headerlink" title="滑腻腻的分割线"></a>滑腻腻的分割线</h3><hr><p><img src="https://s6.postimg.cc/s4ph7eg81/2353844-a0190f7eaf64db0f.png" alt="不同的引用类型和修饰符对于函数派发的影响"></p><h5 id="函数派发就是当调用一个方法时候程序判断以何种调用方法去调用的机制。每次的函数调用都会触发这种机制，但是你又不会注意太多。在编码时候，了解函数的派发机制是至关重要，同时能解释其中的一些令人困惑的问题。"><a href="#函数派发就是当调用一个方法时候程序判断以何种调用方法去调用的机制。每次的函数调用都会触发这种机制，但是你又不会注意太多。在编码时候，了解函数的派发机制是至关重要，同时能解释其中的一些令人困惑的问题。" class="headerlink" title="函数派发就是当调用一个方法时候程序判断以何种调用方法去调用的机制。每次的函数调用都会触发这种机制，但是你又不会注意太多。在编码时候，了解函数的派发机制是至关重要，同时能解释其中的一些令人困惑的问题。"></a>函数派发就是当调用一个方法时候程序判断以何种调用方法去调用的机制。每次的函数调用都会触发这种机制，但是你又不会注意太多。在编码时候，了解函数的派发机制是至关重要，同时能解释其中的一些令人困惑的问题。</h5><p>编译型语言有三种主要的函数派发机制：<strong>直接派发(Direct Dispatch)</strong>、<strong>函数表派发(Table  Dispatch)</strong>、<strong>消息机制派发(Message Dispatch)</strong>，下面我会详细解释这几种机制。大多数语言支持一种或两种。Java默认使用的是函数表派发，但是可以通过 <code>final</code> 关键字来进行直接派发。C++默认使用的是直接派发，但是可以通过 <code>virtual</code> 关键字来进行函数表派发。Objective-C 只能使用消息机制派发, 但允许开发者使用 C 直接派发来获取性能的提高。WTF但是Swift都支持，这很好，同时这个也是大多数开发人员混淆的源头，并且是大多数开发人员遇到过的问题。</p><h3 id="派发的方法-Types-of-Dispatch"><a href="#派发的方法-Types-of-Dispatch" class="headerlink" title="派发的方法(Types of Dispatch )"></a>派发的方法(Types of Dispatch )</h3><p>派发的目的是告诉CPU找到特定方法的可执行的代码搁哪呢。我们在深入了解之前先了解一下这三种派发方法，以及每种方式在动态性和性能之间的取舍。</p><h3 id="直接派发-Direct-Dispatch"><a href="#直接派发-Direct-Dispatch" class="headerlink" title="直接派发 (Direct Dispatch)"></a>直接派发 (Direct Dispatch)</h3><p>直接派发是最快的一种函数派发方法。不但因为在汇编的层面调用的指令集最少，而且编译器还能够有很大的优化空间, 例如函数内联等, 但这不在这篇博客的讨论范围. 直接派发也有人称为静态调用。然而, 对于编程来说直接调用也是最大的局限, 而且因为缺乏动态性所以没办法支持继承。</p><h3 id="函数表派发-Table-Dispatch"><a href="#函数表派发-Table-Dispatch" class="headerlink" title="函数表派发 (Table Dispatch )"></a>函数表派发 (Table Dispatch )</h3><p>函数表派发是编译型语言实现动态化最普遍的实现方式。 函数表派发机制使用了一个数组来存储类声明的每一个函数的指针。 大部分语言把这个称为 “virtual table”(虚函数表)，而在Swift 里称为 “witness table”。每一个子类都有函数表的副本，里面记录着父类所有的函数，重写之后的函数会替代父类对应的函数。 一个子类新添加的函数, 都会被插入到这个数组的最后。在运行时会去查表调用响应的函数。</p><h4 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ParentClass &#123;</span><br><span class="line">    func method1() &#123;&#125;</span><br><span class="line">    func method2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildClass: ParentClass &#123;</span><br><span class="line">    override func method2() &#123;&#125;</span><br><span class="line">    func method3() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个情况下, 编译器会创建两个函数表, 一个是<code>ParentClass</code>的, 另一个是 <code>ChildClass</code>的：<br><img src="https://s6.postimg.cc/l1hlrrvcx/2353844-cb9bd002846a63e2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = ChildClass()</span><br><span class="line">obj.method2()</span><br></pre></td></tr></table></figure><p>####当一个函数被调用时, 会经历下面的几个过程：</p><ul><li>读取函数表中地址为<code>0xB00</code>的对象。</li><li>读取函数指针的索引。在例子里, method2 的索引是1(偏移量), 也就是 0xB00 + 1。</li><li>跳转到<code>0x222</code></li></ul><p>表查找非常简单，易实现的，性能特征是可预知的。然而，与直接调度相比，这种调度方法仍然很慢。从<code>byte-code</code>的角度来看，有两个额外的读取和一个跳转，这同时增加了不少性能开销。另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化。</p><p>这种基于数组的实现, 缺陷在于函数表无法拓展。子类会在虚数函数表的最后插入新的函数，没有位置可以让 extension 安全地插入函数。这篇 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html" target="_blank" rel="noopener">swift-evolution post</a> 很详细地描述了这么做的局限性。</p><h3 id="消息派发-Message-Dispatch"><a href="#消息派发-Message-Dispatch" class="headerlink" title="消息派发 (Message Dispatch )"></a>消息派发 (Message Dispatch )</h3><p>消息派发是最广泛的动态调用函数的方法。也是<code>Cocoa</code>的中流砥柱，这种机制也为  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="noopener">KVO</a>, <a href="https://developer.apple.com/reference/uikit/uiappearance" target="_blank" rel="noopener">UIAppearence</a> 和 <a href="https://developer.apple.com/library/content///documentation/Cocoa/Conceptual/CoreData/index.html" target="_blank" rel="noopener">CoreData</a> 打下了基础。这种机制的关键是允许开发者在运行时改变函数的实现。不仅可使用  <a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html" target="_blank" rel="noopener">swizzling</a> 来改变，还可以用 <a href="http://stackoverflow.com/a/38878119/255489" target="_blank" rel="noopener">isa-swizzling</a> 修改对象的继承关系，可以在面向对象的基础上实现自定义派发。</p><h4 id="再举个🌰"><a href="#再举个🌰" class="headerlink" title="再举个🌰"></a>再举个🌰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ParentClass &#123;</span><br><span class="line">    dynamic func method1() &#123;&#125;</span><br><span class="line">    dynamic func method2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildClass: ParentClass &#123;</span><br><span class="line">    override func method2() &#123;&#125;</span><br><span class="line">    dynamic func method3() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 会用树来构建这种继承关系:<br><img src="https://s6.postimg.cc/a36c90tqp/2353844-1c945171ad5116ee.png" alt=""><br>当一个消息被转发, 运行时会顺着类的继承关系向上查找应该被调用的函数。如果你觉得这样做效率很低, 它确实很低。 然而, 只要缓存建立了起来。这个查找过程就会通过缓存来把性能提高到和函数表派发一样快。但这只是消息机制的原理, 这里有一篇文章<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/" target="_blank" rel="noopener">一篇文章</a>很深入的讲解了具体的技术细节。</p><h3 id="Swift-的派发机制"><a href="#Swift-的派发机制" class="headerlink" title="Swift 的派发机制"></a>Swift 的派发机制</h3><p>那么，Swift是啥派发机制的呢？没有一个固定的的机制，有几种环境因素来影响使用哪种派发机制：</p><ul><li>声明的位置</li><li>引用的类型</li><li>特定的行为</li><li>可见的优化<br>在说明之前, 我有必要说清楚, Swift 没有在文档里具体写明什么时候使用函数表什么时候使用消息派发机制。唯一的承诺是使用 dynamic 修饰的时候会通过 Objective-C 的运行时进行消息机制派发。以下我写的所有东西，都只是我在 Swift 3.0 里测试出来的结果，并且很可能在之后的版本更新里进行修改。博主会在近期使用Swift 4.0进行测试。</li></ul><h3 id="声明的位置-Location-Matters"><a href="#声明的位置-Location-Matters" class="headerlink" title="声明的位置(Location Matters)"></a>声明的位置(Location Matters)</h3><p>Swift有两个地方可以声明一个方法：在类声明的作用域，在extension中。根据声明的类型，这将改变调度的执行方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    func mainMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">extension MyClass &#123;</span><br><span class="line">    func extensionMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，<code>mainMethod</code>将会使用函数表派发，<code>extensionMethod</code>将使用静态派发。当我第一次发现时候，我很意外。我不能确认这些方法有什么不同。下面是我根据类型，声明位置总结出来的函数派发方式的表格：<br><img src="https://s6.postimg.cc/5u1m6uy75/2353844-1d1e0e5b38297401.png" alt="image.png"><br>下面有几条需要注意的：</p><ul><li>值类型总是使用直接派发的。这很易懂！</li><li>Protocol 和 Classes 的 Extensions 使用的是直接派发。</li><li><code>NSObject</code>和<code>NSObject</code>子类的 Extensions 使用的消息派发。</li><li><code>NSObject</code>和<code>NSObject</code>子类的声明作用域里面函数都会使用函数表派发。</li><li>协议里的声明以及带有默认实现的函数会使用函数表派发机制。</li></ul><h3 id="引用类型-Reference-Type-Matters"><a href="#引用类型-Reference-Type-Matters" class="headerlink" title="引用类型 (Reference Type Matters)"></a>引用类型 (Reference Type Matters)</h3><p>引用的类型同时也决定了函数派发的机制。这显而易见，这是一个重要的差异。当一个协议扩展和类型扩展同时实现了同一个函数，这种情况让我们很疑惑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protocol MyProtocol &#123;</span><br><span class="line">&#125;</span><br><span class="line">struct MyStruct: MyProtocol &#123;</span><br><span class="line">&#125;</span><br><span class="line">extension MyStruct &#123;</span><br><span class="line">    func extensionMethod() &#123;</span><br><span class="line">        print(&quot;In Struct&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extension MyProtocol &#123;</span><br><span class="line">    func extensionMethod() &#123;</span><br><span class="line">        print(&quot;In Protocol&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let myStruct = MyStruct()</span><br><span class="line">let proto: MyProtocol = myStruct</span><br><span class="line"> </span><br><span class="line">myStruct.extensionMethod() // -&gt; “In Struct”</span><br><span class="line">proto.extensionMethod() // -&gt; “In Protocol”</span><br></pre></td></tr></table></figure></p><p>大多数刚刚接触Swift的人会认为<code>proto.extensionMethod()</code>调用的是结构体里面的实现。然而，引用的类型决定了派发的方式, 协议拓展里的函数会使用直接调用。如果把 <code>extensionMethod</code> 的声明移动到协议的声明位置的话，则会使用函数表派发，最终就会调用结构体里的实现。<br>而且，如果两种声明都使用的是直接派发，基于直接派发的机制，我们不可能实现重写Protocol里面的实现。这让很多新的Swift开发者会措手不及，这与Objective-C的机制背道而驰。</p><p>Swift JIRA(缺陷跟踪管理系统) 也发现了几个 <a href="https://bugs.swift.org/browse/SR-1422" target="_blank" rel="noopener">bugs</a>，Swfit-Evolution 邮件列表里有一大堆讨论，也有一大堆<a href="https://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future" target="_blank" rel="noopener">博客</a>讨论过这个。但是，这好像是故意这么做的, 虽然官方文档没有提过这件事情😒😒</p><h3 id="指定派发方式-Specifying-Dispatch-Behavior"><a href="#指定派发方式-Specifying-Dispatch-Behavior" class="headerlink" title="指定派发方式 (Specifying Dispatch Behavior)"></a>指定派发方式 (Specifying Dispatch Behavior)</h3><p>Swift有一些修饰符可以指定派发方法。</p><p><strong>final</strong><br><code>final</code>允许类里面声明的函数使用直接派发。这个关键字会移除函数的动态性。任何函数都可以使用这个关键字，甚至是extension里面已经 使用的直接派发的函数。这会让 Objective-C 在运行时获取不到这个函数，同时不会生成函数的<code>selector</code>。</p><p><strong>dynamic</strong><br><code>dynamic</code>可以让类里面的函数使用消息机制派发。使用 <code>dynamic</code>, 必须导入 Foundation 框架，里面包括了 NSObject 和 Objective-C 的运行时。<code>dynamic</code>可以让声明在 extension 里面的函数能够被override。<code>dynamic</code> 可以用在所有NSObject的子类和 Swift 的原生类。</p><p><strong>@objc &amp; @nonobjc</strong><br><code>@objc</code> 和 <code>@nonobjc</code> 声明了一个函数是否能被 Objective-C 的运行时捕获到。 使用 <code>@objc</code> 的典型例子就是给 <code>selector</code> 一个命名空间 <code>@objc(abc_methodName)</code>，让这个函数可以被 Objective-C 的运行时调用。 <code>@nonobjc</code> 会改变派发的方式，可以用来禁止消息机制派发这个函数，不让这个函数注册到 Objective-C 的运行时里。 我不确定这跟 <code>final</code> 有什么区别， 因为从使用场景来说也几乎一样。我个人来说更喜欢 <code>final</code>，因为意图更加明显。个人感觉<code>@objc</code> <code>@nonobjc</code>这两个是为了与OC混编时候更加方便，而<code>final</code>是为Swift准备的原生关键字。</p><p><strong>final @objc</strong><br>可以在标记为 <code>final</code> 的同时，也使用 <code>@objc</code> 来让函数可以使用消息机制派发。这么做的结果就是，调用函数的时候会使用直接派发，但也会在 Objective-C 的运行时里注册响应的 selector。函数可以响应 perform(selector:) 以及别的 Objective-C 特性，但在直接调用时又可以有直接派发的性能。</p><p><strong>@inline</strong><br>Swift 也支持 <code>@inline</code>，告诉编译器可以使用直接派发。有趣的是<code>dynamic @inline(__always) func dynamicOrDirect() {}</code> 也可以通过编译！它仅仅是一个声明，开发者大会表示函数依然是使用消息派发。这就像一个未声明的行为，应该避免这样使用。</p><h3 id="修饰符总结-Modifier-Overview"><a href="#修饰符总结-Modifier-Overview" class="headerlink" title="修饰符总结 (Modifier Overview)"></a>修饰符总结 (Modifier Overview)</h3><p><img src="https://s6.postimg.cc/buzb3x5dt/2353844-2f383cd482292649.png" alt=""><br>这张图总结这些关键字对于 Swift 派发方式的影响，想看范例的话可以看<a href="https://gist.github.com/KingOfBrian/778dc93bffddf25b2c414360727c273b#file-message-swift" target="_blank" rel="noopener">这里</a>。</p><h3 id="显示优化-Visibility-Will-Optimize"><a href="#显示优化-Visibility-Will-Optimize" class="headerlink" title="显示优化 (Visibility Will Optimize)"></a>显示优化 (Visibility Will Optimize)</h3><p>Swift 将会尽力去优化函数派发的方式。例如，如果你有一个函数从来没有 override，Swift 就会检测并且在可能的情况下使用直接派发。这个优化大多数情况下都很好，但对于使用了 target / action 模式的 Cocoa 开发者就不怎么友好了。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    navigationItem.rightBarButtonItem = UIBarButtonItem(</span><br><span class="line">        title: &quot;Sign In&quot;, style: .plain, target: nil,</span><br><span class="line">        action: #selector(ViewController.signInAction)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">private func signInAction() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>编译会抛出一个错误: <code>Argument of &#39;#selector&#39; refers to a method that is not exposed to Objective-C</code>Objective-C 无法获取 #selector 指定的函数。你如果记得 Swift 会把这个函数优化为直接派发的话，就会理解了。 修复这里很简单：加上<code>@objc</code> 或者 <code>dynamic</code> 就可以保证 Objective-C 的运行时可以获取到函数。这种类型的错误也会发生在<code>UIAppearance</code> 上，依赖于 proxy 和 <code>NSInvocation</code>。</p><p>另一点是, 如果你没有使用 <code>dynamic</code> 修饰的话， 这个优化会让 KVO 失效。如果一个属性绑定了 KVO 的话，而这个属性的 getter 和 setter 会被优化为直接派发，代码依旧可以通过编译，不过动态生成的 KVO 函数就不会被触发。</p><p>Swift 的博客有一篇<a href="https://developer.apple.com/swift/blog/?id=27" target="_blank" rel="noopener">很赞的文章</a>描述了相关的细节，和这些优化背后的考虑。</p><h3 id="派发总结-Dispatch-Summary"><a href="#派发总结-Dispatch-Summary" class="headerlink" title="派发总结 (Dispatch Summary)"></a>派发总结 (Dispatch Summary)</h3><p>这里有很多需要记住的规则，所以我整理了一个表格：</p><p><img src="https://s6.postimg.cc/iwx8qpgvl/2353844-43890abe814efa2b.png" alt=""></p><h3 id="NSObject-以及动态性的损失-NSObject-and-the-Loss-of-Dynamic-Behavior"><a href="#NSObject-以及动态性的损失-NSObject-and-the-Loss-of-Dynamic-Behavior" class="headerlink" title="NSObject 以及动态性的损失 (NSObject and the Loss of Dynamic Behavior)"></a>NSObject 以及动态性的损失 (NSObject and the Loss of Dynamic Behavior)</h3><p>之前还有一些 Cocoa 开发者<a href="http://mjtsai.com/blog/2016/05/21/dynamic-swift-2/" target="_blank" rel="noopener">讨论动态行为带来的问题</a>。 这段讨论很有趣，提了一大堆不同的观点。我希望可以在这里继续探讨一下，有几个 Swift 的派发方式我觉得损害了动态性，顺便说一下我的解决方案。</p><h3 id="NSObject-的函数表派发-Table-Dispatch-in-NSObject"><a href="#NSObject-的函数表派发-Table-Dispatch-in-NSObject" class="headerlink" title="NSObject 的函数表派发 (Table Dispatch in NSObject)"></a>NSObject 的函数表派发 (Table Dispatch in NSObject)</h3><p>之前，我说明了一个<code>NSObject</code> 子类作用域里面定义的函数会使用函数表派发。但我觉得很迷惑，很难解释清楚，并且由于下面几个原因，这也只带来了一点点性能的提升：</p><ul><li>大部分 <code>NSObject</code> 的子类都是在 <code>obj_msgSend</code> 的基础上构建的. 我很怀疑这些派发方式的优化，实际到底会给 Cocoa 的子类带来多大的提升.</li><li>大多数 Swift 的 <code>NSObject</code> 子类都会使用 extension 进行拓展, 都没办法使用这种优化。<br>最后, 有一些小细节会让派发方式变得很复杂。</li></ul><h3 id="NSObject-作为一个选择-NSObject-as-a-Choice"><a href="#NSObject-作为一个选择-NSObject-as-a-Choice" class="headerlink" title="NSObject 作为一个选择 (NSObject as a Choice)"></a>NSObject 作为一个选择 (NSObject as a Choice)</h3><p>使用静态派发的话结构体是不错的选择，而使用消息机制派发的话则可以考虑 <code>NSObject</code>。 现在，如果你想跟一个刚学 Swift 的开发者解释为什么某个东西是一个 <code>NSObject</code> 的子类，你不得不去介绍 Objective-C。现在没有任何理由去继承 <code>NSObject</code> 构建类，除非你需要使用 Objective-C 构建的框架。</p><p>目前来说，<code>NSObject</code> 在 Swift 里的派发方式，一个字总结就是TM复杂，跟理想还是有差距。我比较想看到这个修改：当你继承 <code>NSObject</code> 的时候，这是一个你想要完全使用动态消息机制的表现。</p><h3 id="显式动态性声明-Implicit-Dynamic-Modification"><a href="#显式动态性声明-Implicit-Dynamic-Modification" class="headerlink" title="显式动态性声明 (Implicit Dynamic Modification)"></a>显式动态性声明 (Implicit Dynamic Modification)</h3><p>另一个 Swift 可以改进的地方就是函数动态性的检测。我感觉检测到一个函数被 <code>#selector</code> 和 <code>#keypath</code> 引用时要自动把这些函数标记为 <code>dynamic</code>，这样的话就会解决大部分 <code>UIAppearance</code> 的动态问题, 但也许有别的编译时的处理方式可以标记这些函数。</p><h3 id="Error-以及-Bug-Errors-and-Bugs"><a href="#Error-以及-Bug-Errors-and-Bugs" class="headerlink" title="Error 以及 Bug (Errors and Bugs)"></a>Error 以及 Bug (Errors and Bugs)</h3><p>为了让我们对 Swift 的派发方式有更多了解，让我们来看一下 Swift 开发者遇到过的 error。</p><h4 id="SR-584"><a href="#SR-584" class="headerlink" title="SR-584"></a>SR-584</h4><p>这个 <a href="https://bugs.swift.org/browse/SR-584" target="_blank" rel="noopener">Swift bug</a> 是 Swift 函数派发的一个功能。存在于 NSObject 子类声明的函数(函数表派发)，以及声明在 extension 的函数(消息机制派发)中. 为了更好地描述这个情况, 我们先来创建一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person: NSObject &#123;</span><br><span class="line">    func sayHi() &#123;</span><br><span class="line">        print(&quot;Hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func greetings(person: Person) &#123;</span><br><span class="line">    person.sayHi()</span><br><span class="line">&#125;</span><br><span class="line">greetings(person: Person()) // prints &apos;Hello&apos;</span><br></pre></td></tr></table></figure></p><p><code>reetings(person:)</code> 函数使用函数表派发来调用 <code>sayHi()</code>。 就像我们期望的, “Hello” 会被打印。没什么好讲的地方, 那现在让我们继承 <code>Person</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MisunderstoodPerson: Person &#123;&#125;</span><br><span class="line">extension MisunderstoodPerson &#123;</span><br><span class="line">    override func sayHi() &#123;</span><br><span class="line">        print(&quot;No one gets me.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">greetings(person: MisunderstoodPerson()) // prints &apos;Hello&apos;</span><br></pre></td></tr></table></figure></p><p>可以看到去<code>sayHi()</code> 函数是在 extension 里声明的, 会使用消息机制进行调用. 当<code>greetings(person:)</code> 被触发时, <code>sayHi()</code> 会通过函数表被派发到 <code>Person</code> 对象，而<code>misunderstoodPerson</code> 重写之后会使用消息机制，而 <code>MisunderstoodPerson</code> 的函数表依旧保留了 <code>Person</code> 的实现，紧接着歧义就产生了。</p><p>在这里的解决方法是保证函数使用相同的消息派发机制。你可以给函数加上 <code>dynamic</code> 修饰符，或者是把函数的实现从 extension 移动到类最初声明的作用域里。</p><p>理解了 Swift 的派发方式，就能够理解这个行为产生的原因了，虽然 Swift 不应该让我们遇到这问题。</p><p>####SR-103<br>这个 <a href="https://bugs.swift.org/browse/SR-103" target="_blank" rel="noopener">Swift bug</a> 触发了定义在协议拓展的默认实现，即使是子类已经实现这个函数的情况下。为了说明这个问题，我们先定义一个协议，并且给里面的函数一个默认实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol Greetable &#123;</span><br><span class="line">    func sayHi()</span><br><span class="line">&#125;</span><br><span class="line">extension Greetable &#123;</span><br><span class="line">    func sayHi() &#123;</span><br><span class="line">        print(&quot;Hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func greetings(greeter: Greetable) &#123;</span><br><span class="line">    greeter.sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在, 让我们定义一个遵守了这个协议的类。先定义一个 <code>Person</code> 类, 遵守 <code>Greetable</code> 协议，然后定义一个子类 <code>LoudPerson</code>，重写<code>sayHi()</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person: Greetable &#123;</span><br><span class="line">&#125;</span><br><span class="line">class LoudPerson: Person &#123;</span><br><span class="line">    func sayHi() &#123;</span><br><span class="line">        print(&quot;HELLO&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你们发现 <code>LoudPerson</code> 实现的函数前面没有 <code>override</code> 修饰，这是一个提示，也许代码不会像我们设想的那样运行。在这个例子里，<code>LoudPerson</code> 没有在 <code>Greetable</code> 的协议记录表里成功注册，当 <code>sayHi()</code>通过 <code>Greetable</code> 协议派发时，默认的实现就会被调用。</p><p>解决的方法就是，在类声明的作用域里就要提供所有协议里定义的函数，即使已经有默认实现。或者，你可以在类的前面加上一个<code>final</code> 修饰符，保证这个类不会被继承。</p><p>Doug Gregor 在 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html" target="_blank" rel="noopener">Swift-Evolution 邮件列表</a>里提到，通过显式地重新把函数声明为类的函数，就可以解决这个问题，并且不会偏离我们的设想。</p><h4 id="因吹斯汀-Error-Interesting-Error"><a href="#因吹斯汀-Error-Interesting-Error" class="headerlink" title="因吹斯汀 Error (Interesting Error)"></a>因吹斯汀 Error (Interesting Error)</h4><p>有一个很好玩的编译错误, 可以窥见到 Swift 的计划. 就像之前说的, 类拓展使用直接派发, 所以你试图 override 一个声明在 extension 里的函数的时候会发生什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">&#125;</span><br><span class="line">extension MyClass &#123;</span><br><span class="line">    func extensionMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class SubClass: MyClass &#123;</span><br><span class="line">    override func extensionMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码会触发一个编译错误 <code>Declarations in extensions can not be overridden yet</code>(声明在 extension 里的方法不可以被重写)。这可能是 Swift 团队打算加强函数表派发的一个征兆。又或者这只是我过度解读，觉得这门语言可以优化的地方。</p><p><img src="https://s6.postimg.cc/6jkej86gh/2353844-5ff4219d8ccc509d.gif" alt=""></p><h3 id="致谢-Thanks"><a href="#致谢-Thanks" class="headerlink" title="致谢 Thanks"></a>致谢 Thanks</h3><p>我希望了解函数派发机制的过程中你感受到了乐趣，并且可以帮助你更好的理解 Swift。虽然我抱怨了 <code>NSObject</code> 相关的一些东西，但我还是觉得 Swift 提供了高性能的可能性，我只是希望可以有足够简单的方式，让这篇博客没有存在的必要。<br>原文:</p><ul><li>原文： <a href="https://www.raizlabs.com/dev/2016/12/swift-method-dispatch/?utm_campaign=This+Week+in+Swift&amp;utm_medium=email&amp;utm_source=This_Week_in_Swift_114" target="_blank" rel="noopener">Method Dispatch in Swift</a></li><li>作者： <a href="https://www.raizlabs.com/dev/author/brian-kingraizlabs-com/" target="_blank" rel="noopener">Brain King</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了-zhuang-解-bi-一下。&quot;&gt;&lt;a href=&quot;#已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了-zhuang-解-bi-一下。&quot; class=&quot;headerlink&quot; title=&quot;已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了(zhuang)解(bi)一下。&quot;&gt;&lt;/a&gt;已经使用Swift这门新兴的OO语言已经有很久了，作为面向对象语言在没有特殊声明的时候系统会默认对属性和方法进行重载，虽说Swift不完全算一种动态语言，但是由于和OC依然藕断丝连Swift里面动态派发依然会损耗不小的性能，那么动态派发是什么，Swift的派发机制是什么？我们来深入了(zhuang)解(bi)一下。&lt;/h3&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>RN 原生混编中的本地离线打包</title>
    <link href="http://yoursite.com/2017/10/14/RN-%E5%8E%9F%E7%94%9F%E6%B7%B7%E7%BC%96%E4%B8%AD%E7%9A%84%E6%9C%AC%E5%9C%B0%E7%A6%BB%E7%BA%BF%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2017/10/14/RN-原生混编中的本地离线打包/</id>
    <published>2017-10-14T13:40:50.000Z</published>
    <updated>2018-07-02T10:42:16.725Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s6.postimg.cc/q0545sbv5/2353844-8653a172b647fafc.png" alt=""></p><a id="more"></a><h4 id="RN这种面向生产力的框架介绍的文档网上一堆，就不和大家介绍了，我们前端框架刚好是React，我们的构想就是移动端和前端有更多的互动，在不加人头的基础上提高开发迭代速度"><a href="#RN这种面向生产力的框架介绍的文档网上一堆，就不和大家介绍了，我们前端框架刚好是React，我们的构想就是移动端和前端有更多的互动，在不加人头的基础上提高开发迭代速度" class="headerlink" title="RN这种面向生产力的框架介绍的文档网上一堆，就不和大家介绍了，我们前端框架刚好是React，我们的构想就是移动端和前端有更多的互动，在不加人头的基础上提高开发迭代速度"></a>RN这种面向生产力的框架介绍的文档网上一堆，就不和大家介绍了，我们前端框架刚好是React，我们的构想就是移动端和前端有更多的互动，在不加人头的基础上提高开发迭代速度</h4><h5 id="本文基于原生与RN-0-48-混编的项目来描述，前提是您已经将RN框架导入到项目并可以正常运行，我们的项目目录结构与RN原生项目有着相同的目录结构"><a href="#本文基于原生与RN-0-48-混编的项目来描述，前提是您已经将RN框架导入到项目并可以正常运行，我们的项目目录结构与RN原生项目有着相同的目录结构" class="headerlink" title="本文基于原生与RN(0.48)混编的项目来描述，前提是您已经将RN框架导入到项目并可以正常运行，我们的项目目录结构与RN原生项目有着相同的目录结构"></a>本文基于原生与RN(0.48)混编的项目来描述，前提是您已经将RN框架导入到项目并可以正常运行，我们的项目目录结构与RN原生项目有着相同的目录结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--entry-file &lt;path&gt;                Path to the root JS file, either absolute or relative to JS root</span><br><span class="line">RN项目的入口文件相对/相对路径</span><br><span class="line">--platform [string]                Either &quot;ios&quot; or &quot;android&quot;</span><br><span class="line">输入‘ios’或‘android’</span><br><span class="line">--transformer [string]             Specify a custom transformer to be used</span><br><span class="line">指定自定义的transformer文件绝对/相对路径[default: &quot;./node_modules/react-native/packager/transformer.js&quot;]</span><br><span class="line">--dev [boolean]                    If false, warnings are disabled and the bundle is minified</span><br><span class="line">如果为false, 不显示警告并且bundle会变小[default: true]</span><br><span class="line">--bundle-output &lt;string&gt;           File name where to store the resulting bundle, ex. /tmp/groups.bundle</span><br><span class="line">打包后的文件输出目录, 例: /tmp/groups.bundle</span><br><span class="line">--bundle-encoding [string]         Encoding the bundle should be written in (https://nodejs.org/api/buffer.html#buffer_buffer).</span><br><span class="line">归档文件至 可参考链接https://nodejs.org/api/buffer.html#buffer_buffer.</span><br><span class="line">--max-workers [number]             Specifies the maximum number of workers the worker-pool will spawn for transforming files. This defaults to the number of the cores available on your machine.</span><br><span class="line">指定用于产生转换文件的worker-pool的最大工作数，默认与设备处理器核心相同</span><br><span class="line">--sourcemap-output [string]        File name where to store the sourcemap file for resulting bundle, ex. /tmp/groups.map</span><br><span class="line">映射文件的名称</span><br><span class="line">--sourcemap-sources-root [string]  Path to make sourcemap&apos;s sources entries relative to, ex. /root/dir</span><br><span class="line">映射文件的路径</span><br><span class="line">--sourcemap-use-absolute-path      Report SourceMapURL using its full path</span><br><span class="line">使用SourceMapURL的绝对路径</span><br><span class="line">--assets-dest [string]             Directory name where to store assets referenced in the bundle</span><br><span class="line">打包图片资源的存储的绝对/相对路径</span><br><span class="line">--verbose                          Enables logging</span><br><span class="line">显示打包过程</span><br><span class="line">--reset-cache                      Removes cached files</span><br><span class="line">清除缓存文件</span><br><span class="line">--read-global-cache                Try to fetch transformed JS code from the global cache, if configured.</span><br><span class="line">--config [string]                  Path to the CLI configuration file</span><br><span class="line">命令行的配置文件路径</span><br><span class="line">-h, --help                         output usage information</span><br></pre></td></tr></table></figure><h4 id="我们以原生的RN空项目为例"><a href="#我们以原生的RN空项目为例" class="headerlink" title="我们以原生的RN空项目为例"></a>我们以原生的RN空项目为例</h4><h5 id="执行打包命令，我们直接将打包的文件打进工程"><a href="#执行打包命令，我们直接将打包的文件打进工程" class="headerlink" title="执行打包命令，我们直接将打包的文件打进工程"></a>执行打包命令，我们直接将打包的文件打进工程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --entry-file index.ios.js --bundle-output ./ios/XXX/index.ios.jsbundle --platform ios --assets-dest ./ios/XXX/ --dev false</span><br></pre></td></tr></table></figure><h5 id="执行后的目录-项目中没有引入图片等资源，没有asset文件"><a href="#执行后的目录-项目中没有引入图片等资源，没有asset文件" class="headerlink" title="执行后的目录(项目中没有引入图片等资源，没有asset文件)"></a>执行后的目录(项目中没有引入图片等资源，没有asset文件)</h5><p><img src="https://s6.postimg.cc/65j2jqoyp/2353844-f7e023be1e9ea2c8.png" alt=""></p><h5 id="将jsbundle文件和asset目录导入项目"><a href="#将jsbundle文件和asset目录导入项目" class="headerlink" title="将jsbundle文件和asset目录导入项目"></a>将jsbundle文件和asset目录导入项目</h5><p><em>assets 目录导入工程中时，要选择 Create folder references，因为这是图片素材。</em><br><em>还有个很关键的就是，jsbundle文件一定要导入到copy bundle resources 里面，不然之后通过ios原生的<code>path(forResource: &quot;main.jsbundle&quot;, ofType: nil)</code>这个方法找不到路径</em></p><p><img src="https://s6.postimg.cc/7xc1eng1d/2353844-ec35ed2aabdb8007.png" alt=""></p><h4 id="希望我的文章能帮助到大家"><a href="#希望我的文章能帮助到大家" class="headerlink" title="希望我的文章能帮助到大家~"></a>希望我的文章能帮助到大家~</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s6.postimg.cc/q0545sbv5/2353844-8653a172b647fafc.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Xcode9 xcodebuild 打包上传蒲公英</title>
    <link href="http://yoursite.com/2017/10/09/Xcode9-xcodebuild-%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    <id>http://yoursite.com/2017/10/09/Xcode9-xcodebuild-打包上传蒲公英/</id>
    <published>2017-10-09T14:00:58.000Z</published>
    <updated>2018-07-02T10:37:21.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App-Store的脚本，本文默认您已经进行过打包流程并成功"><a href="#最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App-Store的脚本，本文默认您已经进行过打包流程并成功" class="headerlink" title="最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App Store的脚本，本文默认您已经进行过打包流程并成功"></a>最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App Store的脚本，本文默认您已经进行过打包流程并成功</h3><a id="more"></a><h5 id="在正式版Xcode9更新之后，之前的脚本无法使用，报错如下"><a href="#在正式版Xcode9更新之后，之前的脚本无法使用，报错如下" class="headerlink" title="在正式版Xcode9更新之后，之前的脚本无法使用，报错如下"></a>在正式版Xcode9更新之后，之前的脚本无法使用，报错如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: exportArchive: &quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.</span><br><span class="line">Error Domain=IDEProvisioningErrorDomain Code=9</span><br></pre></td></tr></table></figure><h5 id="首先我们需要先进行-xcodebuild-export-plist-配置"><a href="#首先我们需要先进行-xcodebuild-export-plist-配置" class="headerlink" title="首先我们需要先进行 xcodebuild export plist 配置"></a>首先我们需要先进行 xcodebuild export plist 配置</h5><h5 id="如下图所示，一步一步做"><a href="#如下图所示，一步一步做" class="headerlink" title="如下图所示，一步一步做"></a>如下图所示，一步一步做</h5><p><img src="https://s6.postimg.cc/fq2p6ubsh/2353844-9b5471a4061e1e6d.png" alt="我们手动进行打包操作"></p><p><img src="https://s6.postimg.cc/4dq3p2ij5/2353844-22fec9045a3537c6.png" alt="打包~~~"></p><p><img src="https://s6.postimg.cc/mgj6gam3l/2353844-4dc56709392ea722.png" alt="打包~~~"></p><p><img src="https://s6.postimg.cc/gscvpex6p/2353844-0acb5eac86b88a7c.png" alt="打包~~~"></p><p><img src="https://s6.postimg.cc/ol3jheavl/2353844-d8126c80fb8a7998.png" alt="我们就要这个plist文件"></p><p><img src="https://s6.postimg.cc/fq2p6vtsx/2353844-f1f9adb9b6d83262.png" alt="image.png"></p><h5 id="我们还要将里面的compileBitcode设置为NO-这个很关键，不然会出现一系列有趣的问题，关于Bitcode的问题可以看官网App-Thinning-下面我们的比较关键的一步就完成了"><a href="#我们还要将里面的compileBitcode设置为NO-这个很关键，不然会出现一系列有趣的问题，关于Bitcode的问题可以看官网App-Thinning-下面我们的比较关键的一步就完成了" class="headerlink" title="我们还要将里面的compileBitcode设置为NO,这个很关键，不然会出现一系列有趣的问题，关于Bitcode的问题可以看官网App Thinning,下面我们的比较关键的一步就完成了"></a>我们还要将里面的<code>compileBitcode</code>设置为<code>NO</code>,这个很关键，不然会出现一系列有趣的问题，关于<code>Bitcode</code>的问题可以看官网<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html" target="_blank" rel="noopener">App Thinning</a>,下面我们的比较关键的一步就完成了</h5><h5 id="下面就是我没有改设置的报错，一脸蒙B…-没有任何提示…"><a href="#下面就是我没有改设置的报错，一脸蒙B…-没有任何提示…" class="headerlink" title="下面就是我没有改设置的报错，一脸蒙B… 没有任何提示…"></a>下面就是我没有改设置的报错，一脸蒙B… 没有任何提示…</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segmentation fault: 11</span><br></pre></td></tr></table></figure><h3 id="下面我们开始打包"><a href="#下面我们开始打包" class="headerlink" title="下面我们开始打包"></a>下面我们开始打包</h3><h5 id="我们打包的前提是需要自动配置证书，打包的模式是Release，请设置对应的值，我们在脚本里不需要设置CODE-SIGN-IDENTITY和PROVISIONING-PROFILE"><a href="#我们打包的前提是需要自动配置证书，打包的模式是Release，请设置对应的值，我们在脚本里不需要设置CODE-SIGN-IDENTITY和PROVISIONING-PROFILE" class="headerlink" title="我们打包的前提是需要自动配置证书，打包的模式是Release，请设置对应的值，我们在脚本里不需要设置CODE_SIGN_IDENTITY和PROVISIONING_PROFILE"></a><em>我们打包的前提是需要自动配置证书，打包的模式是Release，请设置对应的值，我们在脚本里不需要设置<code>CODE_SIGN_IDENTITY</code>和<code>PROVISIONING_PROFILE</code></em></h5><p><img src="https://s6.postimg.cc/uysmknv75/2353844-b77cf4a888c2c0d1.png" alt="image.png"></p><p><img src="https://s6.postimg.cc/5g0a7njcx/2353844-d11066a8c2a8af67.png" alt="image.png"></p><h5 id="由于我们有正式接口和测试接口包需要交付测试测试，我们这边就需要手动打包两次获取对应ExportOptions-plist"><a href="#由于我们有正式接口和测试接口包需要交付测试测试，我们这边就需要手动打包两次获取对应ExportOptions-plist" class="headerlink" title="由于我们有正式接口和测试接口包需要交付测试测试，我们这边就需要手动打包两次获取对应ExportOptions.plist"></a>由于我们有正式接口和测试接口包需要交付测试测试，我们这边就需要手动打包两次获取对应ExportOptions.plist</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">#go!</span><br><span class="line"></span><br><span class="line">PREFIX_SYMBOL=&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;开始上传\n\n&quot;</span><br><span class="line"></span><br><span class="line">#工程名</span><br><span class="line">PROJECTNAME=&quot;XXX&quot;</span><br><span class="line">#需要编译的 targetName</span><br><span class="line">TARGET_NAME=&quot;XXX&quot;</span><br><span class="line">#是否是工作空间</span><br><span class="line">ISWORKSPACE=true</span><br><span class="line"># 开始时间</span><br><span class="line">DATE=`date &apos;+%Y-%m-%d-%T&apos;`</span><br><span class="line">#编译模式 工程默认有 Debug Release </span><br><span class="line">CONFIGURATION_TARGET=Release</span><br><span class="line">#编译路径</span><br><span class="line">BUILDPATH=~/Desktop/$&#123;TARGET_NAME&#125;_$&#123;DATE&#125;</span><br><span class="line">#archivePath</span><br><span class="line">ARCHIVEPATH=$&#123;BUILDPATH&#125;/$&#123;TARGET_NAME&#125;.xcarchive</span><br><span class="line">#输出的ipa目录</span><br><span class="line">IPAPATH=$&#123;BUILDPATH&#125;</span><br><span class="line">#导出ipa 所需plist</span><br><span class="line">FormalExportOptionsPlist=./FormalExportOptions.plist</span><br><span class="line">TestExportOptionsPlist=./TestExportOptions.plist</span><br><span class="line">ExportOptionsPlist=$&#123;FormalExportOptionsPlist&#125;</span><br><span class="line"># 是否上传蒲公英</span><br><span class="line">UPLOADPGYER=false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;选择接口$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">echo &quot;1 正式接口$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">echo &quot;2 测试接口$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">echo &quot;默认正式接口$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 读取用户输入并存到变量里</span><br><span class="line">read parameter</span><br><span class="line">sleep 0.5</span><br><span class="line"></span><br><span class="line"># 判读用户是否有输入 </span><br><span class="line">if [ -n &quot;$parameter&quot; ]</span><br><span class="line">then</span><br><span class="line">if [ &quot;$method&quot; = &quot;1&quot; ]</span><br><span class="line">then</span><br><span class="line">ExportOptionsPlist=$&#123;FormalExportOptionsPlist&#125;</span><br><span class="line">elif [ &quot;$method&quot; = &quot;2&quot; ]</span><br><span class="line">then</span><br><span class="line">ExportOptionsPlist=$&#123;TestExportOptionsPlist&#125;</span><br><span class="line">else</span><br><span class="line">echo &quot;参数无效&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">else</span><br><span class="line">ExportOptionsPlist=$&#123;FormalExportOptionsPlist&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;上传蒲公英$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">echo &quot;1 不上传$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">echo &quot;2 上传$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">echo &quot;默认不上传$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line"></span><br><span class="line">read para</span><br><span class="line">sleep 0.5</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$para&quot; ]</span><br><span class="line">then</span><br><span class="line">if [ &quot;$para&quot; = &quot;1&quot; ]</span><br><span class="line">then </span><br><span class="line">UPLOADPGYER=false</span><br><span class="line">elif [ &quot;$para&quot; = &quot;2&quot; ]</span><br><span class="line">then</span><br><span class="line">UPLOADPGYER=true</span><br><span class="line">else</span><br><span class="line">echo &quot;参数无效....&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">else</span><br><span class="line">UPLOADPGYER=false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;输出相关编译参数$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [ $ISWORKSPACE = true ]</span><br><span class="line">then</span><br><span class="line">echo &quot;项目基于工作空间&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;项目不是基于工作空间&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;编译模式: $&#123;CONFIGURATION_TARGET&#125;&quot;</span><br><span class="line">echo &quot;导出ipa配置文件路径: $&#123;ExportOptionsPlist&#125;&quot;</span><br><span class="line">echo &quot;打包文件路径: $&#123;ARCHIVEPATH&#125;&quot;</span><br><span class="line">echo &quot;导出ipa路径: $&#123;IPAPATH&#125;&quot;</span><br><span class="line">echo &quot;直接点击回车继续，输入任意退出$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line"></span><br><span class="line">read continue_work</span><br><span class="line">sleep 0.5</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$continue_work&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;退出$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">exit 1</span><br><span class="line">else</span><br><span class="line">echo &quot;开始编译$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ $ISWORKSPACE = true ]</span><br><span class="line">then</span><br><span class="line"># 清理</span><br><span class="line">xcodebuild clean -workspace $&#123;PROJECTNAME&#125;.xcworkspace \</span><br><span class="line">-configuration \</span><br><span class="line">$&#123;CONFIGURATION&#125; -alltargets</span><br><span class="line">#开始构建</span><br><span class="line">xcodebuild archive -workspace $&#123;PROJECTNAME&#125;.xcworkspace \</span><br><span class="line">-scheme $&#123;TARGET_NAME&#125; \</span><br><span class="line">-archivePath $&#123;ARCHIVEPATH&#125; \</span><br><span class="line">-configuration $&#123;CONFIGURATION_TARGET&#125;</span><br><span class="line">else</span><br><span class="line"># 清理</span><br><span class="line">xcodebuild clean -project $&#123;PROJECTNAME&#125;.xcodeproj \</span><br><span class="line">-configuration \</span><br><span class="line">$&#123;CONFIGURATION&#125; -alltargets</span><br><span class="line">#开始构建</span><br><span class="line">xcodebuild archive -project $&#123;PROJECTNAME&#125;.xcodeproj \</span><br><span class="line">-scheme $&#123;TARGET_NAME&#125; \</span><br><span class="line">-archivePath $&#123;ARCHIVEPATH&#125; \</span><br><span class="line">-configuration $&#123;CONFIGURATION_TARGET&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;是否构建成功$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line"># xcarchive 实际是一个文件夹不是一个文件所以使用 -d 判断</span><br><span class="line">if [ -d &quot;$ARCHIVEPATH&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;成功$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;失败$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">rm -rf $BUILDPATH</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">xcodebuild -exportArchive \</span><br><span class="line">-archivePath $&#123;ARCHIVEPATH&#125; \</span><br><span class="line">-exportOptionsPlist $&#123;ExportOptionsPlist&#125; \</span><br><span class="line">-exportPath $&#123;IPAPATH&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;检查是否成功导出ipa$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">IPAPATH=$&#123;IPAPATH&#125;/$&#123;TARGET_NAME&#125;.ipa</span><br><span class="line">if [ -f &quot;$IPAPATH&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;导出ipa成功$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">open $BUILDPATH</span><br><span class="line">else</span><br><span class="line">echo &quot;导出ipa失败$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 上传蒲公英</span><br><span class="line">if [ $UPLOADPGYER = true ]</span><br><span class="line">then</span><br><span class="line">echo &quot;上传ipa到蒲公英$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">curl -F &quot;file=@$IPAPATH&quot; \</span><br><span class="line">    -F &quot;installType=2&quot; \</span><br><span class="line">-F &quot;uKey=XXXX&quot; \</span><br><span class="line">-F &quot;_api_key=XXXX&quot; \</span><br><span class="line">-F &quot;password=XXXX&quot; \</span><br><span class="line">    https://www.pgyer.com/apiv2/app/upload</span><br><span class="line"></span><br><span class="line">if [ $? = 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;上传成功$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;上传失败$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;配置信息$&#123;PREFIX_SYMBOL&#125;&quot;</span><br><span class="line">echo &quot;编译模式: $&#123;CONFIGURATION_TARGET&#125;&quot;</span><br><span class="line">echo &quot;导出ipa配置文件: $&#123;ExportOptionsPlist&#125;&quot;</span><br><span class="line">echo &quot;打包文件路径: $&#123;ARCHIVEPATH&#125;&quot;</span><br><span class="line">echo &quot;导出ipa路径: $&#123;IPAPATH&#125;&quot;</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h5 id="24行开始我们填入的是之前我们导出的ExportOptions-plist，上传蒲公英部分的参数可以参照官方文档，我们将打包的路径都设置成了桌面"><a href="#24行开始我们填入的是之前我们导出的ExportOptions-plist，上传蒲公英部分的参数可以参照官方文档，我们将打包的路径都设置成了桌面" class="headerlink" title="24行开始我们填入的是之前我们导出的ExportOptions.plist，上传蒲公英部分的参数可以参照官方文档，我们将打包的路径都设置成了桌面"></a>24行开始我们填入的是之前我们导出的ExportOptions.plist，上传蒲公英部分的参数可以参照<a href="https://www.pgyer.com/doc/view/api#uploadApp" target="_blank" rel="noopener">官方文档</a>，我们将打包的路径都设置成了桌面</h5><h3 id="然而这个脚本并不是大家拿去都能用，也是需要根据自己的项目来设置相应的环境变量，希望能帮助到大家！"><a href="#然而这个脚本并不是大家拿去都能用，也是需要根据自己的项目来设置相应的环境变量，希望能帮助到大家！" class="headerlink" title="然而这个脚本并不是大家拿去都能用，也是需要根据自己的项目来设置相应的环境变量，希望能帮助到大家！"></a>然而这个脚本并不是大家拿去都能用，也是需要根据自己的项目来设置相应的环境变量，希望能帮助到大家！</h3><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://github.com/2016321/xcodebuild_shell" target="_blank" rel="noopener">Demo</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App-Store的脚本，本文默认您已经进行过打包流程并成功&quot;&gt;&lt;a href=&quot;#最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App-Store的脚本，本文默认您已经进行过打包流程并成功&quot; class=&quot;headerlink&quot; title=&quot;最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App Store的脚本，本文默认您已经进行过打包流程并成功&quot;&gt;&lt;/a&gt;最近在弄持续集成方案，因为Jenkins自动打包同样要使用手动触发，同时也不需要定时去打包上传，我们就写了一个shell脚本，当模块完成时候去上传蒲公英交付测试，之后会写一个使用ApplicationLoader上传App Store的脚本，本文默认您已经进行过打包流程并成功&lt;/h3&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>删除WKWebView的cookies信息</title>
    <link href="http://yoursite.com/2017/09/25/%E5%88%A0%E9%99%A4WKWebView%E7%9A%84cookies%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2017/09/25/删除WKWebView的cookies信息/</id>
    <published>2017-09-25T07:55:47.000Z</published>
    <updated>2018-07-02T10:43:25.739Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点"><a href="#自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点" class="headerlink" title="自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点"></a>自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点</h4><a id="more"></a><blockquote><p>关于WKWebView特性：<br>在性能、稳定性、功能方面有很大提升；<br>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；<br>支持了更多的HTML5特性；<br>高达60fps的滚动刷新率以及内置手势；<br>将UIWebView 和 UIWebViewDelegate 重构成了14类与3个协议；</p></blockquote><h4 id="由于需求原因，我们的WKWebView需要经常去清理cookies及相关的缓存"><a href="#由于需求原因，我们的WKWebView需要经常去清理cookies及相关的缓存" class="headerlink" title="由于需求原因，我们的WKWebView需要经常去清理cookies及相关的缓存"></a>由于需求原因，我们的WKWebView需要经常去清理cookies及相关的缓存</h4><h5 id="下面的hostStr-，是我们的域名，每次deinit方法时候进行清除相关缓存工作以便于之后运营修改数据之后前台及时更改"><a href="#下面的hostStr-，是我们的域名，每次deinit方法时候进行清除相关缓存工作以便于之后运营修改数据之后前台及时更改" class="headerlink" title="下面的hostStr ，是我们的域名，每次deinit方法时候进行清除相关缓存工作以便于之后运营修改数据之后前台及时更改"></a>下面的hostStr ，是我们的域名，每次deinit方法时候进行清除相关缓存工作以便于之后运营修改数据之后前台及时更改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 9.0, *) &#123;</span><br><span class="line">            let websiteDataTypes: Set&lt;String&gt; = WKWebsiteDataStore.allWebsiteDataTypes()</span><br><span class="line">            WKWebsiteDataStore.default().fetchDataRecords(ofTypes: websiteDataTypes , completionHandler: &#123; (arr) in</span><br><span class="line">                for record in arr&#123;</span><br><span class="line">                    print(record.displayName)</span><br><span class="line">                    if record.displayName.contains(hostStr)&#123;</span><br><span class="line">                        WKWebsiteDataStore.default().removeData(ofTypes: record.dataTypes, for: [record], completionHandler: &#123; </span><br><span class="line">                            print(&quot;已删除\(record.displayName)&quot;)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let libraryPath = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true)[0]</span><br><span class="line">            let cookiesFolderPath = libraryPath.appendingFormat(&quot;/Cookies&quot;)</span><br><span class="line">            try? FileManager.default.removeItem(atPath: cookiesFolderPath)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="我们可以在控制台打印cookies对应的域名，和数据的类型，此方法可以删除特定域名下的cookies"><a href="#我们可以在控制台打印cookies对应的域名，和数据的类型，此方法可以删除特定域名下的cookies" class="headerlink" title="我们可以在控制台打印cookies对应的域名，和数据的类型，此方法可以删除特定域名下的cookies"></a>我们可以在控制台打印cookies对应的域名，和数据的类型，此方法可以删除特定域名下的cookies</h5><h3 id="希望能帮助到大家"><a href="#希望能帮助到大家" class="headerlink" title="希望能帮助到大家~"></a>希望能帮助到大家~</h3>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点&quot;&gt;&lt;a href=&quot;#自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点&quot; class=&quot;headerlink&quot; title=&quot;自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点&quot;&gt;&lt;/a&gt;自WKWebView出来之后好多app都将沉重的UIWebView换成了WKWebView，其优点大致有以下几点&lt;/h4&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 去除UITextView Padding</title>
    <link href="http://yoursite.com/2017/08/08/Swift-%E5%8E%BB%E9%99%A4UITextView-Padding/"/>
    <id>http://yoursite.com/2017/08/08/Swift-去除UITextView-Padding/</id>
    <published>2017-08-08T05:05:14.000Z</published>
    <updated>2018-07-02T10:42:08.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下"><a href="#我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下" class="headerlink" title="我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下"></a>我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//内容缩进为0（去除左右边距）</span><br><span class="line">textView.textContainer.lineFragmentPadding = 0</span><br><span class="line">//文本边距设为0（去除上下边距）</span><br><span class="line">textView.textContainerInset = .zero</span><br></pre></td></tr></table></figure><h3 id="如图，上面的textView就是-经过处理的"><a href="#如图，上面的textView就是-经过处理的" class="headerlink" title="如图，上面的textView就是 经过处理的"></a>如图，上面的textView就是 经过处理的</h3><p><img src="https://s6.postimg.cc/6v1uw7coh/2353844-765af68f7ddc8a27.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下&quot;&gt;&lt;a href=&quot;#我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下&quot; class=&quot;headerlink&quot; title=&quot;我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下&quot;&gt;&lt;/a&gt;我们经常会用到UILabel来显示只读的文本，在多行需要限制显示范围时候就要用到UITextView，但是UITextView周围都会添加边距，我们可以这样处理一下&lt;/h3&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 获取device token</title>
    <link href="http://yoursite.com/2017/08/01/Swift-%E8%8E%B7%E5%8F%96device-token/"/>
    <id>http://yoursite.com/2017/08/01/Swift-获取device-token/</id>
    <published>2017-08-01T07:56:21.000Z</published>
    <updated>2018-07-02T10:42:11.910Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取device-token，按照友盟的文档，我做了如下操作"><a href="#在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取device-token，按照友盟的文档，我做了如下操作" class="headerlink" title="在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取device token，按照友盟的文档，我做了如下操作"></a>在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取<code>device token</code>，按照友盟的文档，我做了如下操作</h5><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) &#123;</span><br><span class="line">    let tokenStr = deviceToken.description.replacingOccurrences(of: &quot;&lt;&quot;, with: &quot;&quot;).replacingOccurrences(of: &quot;&gt;&quot;, with: &quot;&quot;).replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;)</span><br><span class="line">    print(tokenStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s6.postimg.cc/koq7l9kpd/2353844-74cf9ad4c27cbc06.png" alt="image.png"></p><h5 id="打印出来什么鬼。。。"><a href="#打印出来什么鬼。。。" class="headerlink" title="打印出来什么鬼。。。"></a>打印出来什么鬼。。。</h5><h6 id="看了一下发现deviceToken参数和OC中的类型不相同，Data、NSData之分，同时使用description输出却的不同，果断这样处理，中间转换一下"><a href="#看了一下发现deviceToken参数和OC中的类型不相同，Data、NSData之分，同时使用description输出却的不同，果断这样处理，中间转换一下" class="headerlink" title="看了一下发现deviceToken参数和OC中的类型不相同，Data、NSData之分，同时使用description输出却的不同，果断这样处理，中间转换一下"></a>看了一下发现<code>deviceToken</code>参数和OC中的类型不相同，Data、NSData之分，同时使用<code>description</code>输出却的不同，果断这样处理，中间转换一下</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let deviceTokenData = NSData.init(data: deviceToken)</span><br><span class="line">let tokenStr = deviceTokenData.description.replacingOccurrences(of: &quot;&lt;&quot;, with: &quot;&quot;).replacingOccurrences(of: &quot;&gt;&quot;, with: &quot;&quot;).replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取device-token，按照友盟的文档，我做了如下操作&quot;&gt;&lt;a href=&quot;#在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取device-token，按照友盟的文档，我做了如下操作&quot; class=&quot;headerlink&quot; title=&quot;在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取device token，按照友盟的文档，我做了如下操作&quot;&gt;&lt;/a&gt;在做推送通知的时候发现一个尴尬的事情，在测试推送时候需要获取&lt;code&gt;device token&lt;/code&gt;，按照友盟的文档，我做了如下操作&lt;/h5&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift下拉波浪动画</title>
    <link href="http://yoursite.com/2017/06/01/Swift%E4%B8%8B%E6%8B%89%E6%B3%A2%E6%B5%AA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/06/01/Swift下拉波浪动画/</id>
    <published>2017-06-01T05:00:11.000Z</published>
    <updated>2018-07-02T10:42:00.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点"><a href="#我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点" class="headerlink" title="我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点"></a>我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点</h3><a id="more"></a><p><img src="https://s6.postimg.cc/twig1yzhd/2353844-6ae81c0421c128b3.gif" alt="Demo.gif"></p><h5 id="水波动画的重点就是sin、cos函数"><a href="#水波动画的重点就是sin、cos函数" class="headerlink" title="水波动画的重点就是sin、cos函数"></a>水波动画的重点就是<code>sin</code>、<code>cos</code>函数</h5><p>我们来复习一下不知道是初中还是高中的知识</p><p>正弦型函数解析式：y=Asin（ωx+φ）+h<br>φ（初相位）：决定波形与X轴位置关系或横向移动距离（左加右减）<br>ω：决定周期（最小正周期T=2π/|ω|）<br>A：决定峰值（即纵向拉伸压缩的倍数）<br>h：表示波形在Y轴的位置关系或纵向移动距离（上加下减）</p><p><img src="https://s6.postimg.cc/cj85n4jlt/2353844-be2e65f14a0bfe5b.png" alt="image.png"></p><h3 id="po出项目中的属性"><a href="#po出项目中的属性" class="headerlink" title="po出项目中的属性"></a>po出项目中的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private struct BingoWaveRefreshViewData&#123;</span><br><span class="line">        /// 最大波峰</span><br><span class="line">        static var maxVariable : CGFloat = 1.6</span><br><span class="line">        /// 最小波峰</span><br><span class="line">        static var minVariable : CGFloat = 1.0</span><br><span class="line">        /// 最小波峰增量</span><br><span class="line">        static var minStepLength : CGFloat = 0.01</span><br><span class="line">        /// 最大波峰增量</span><br><span class="line">        static var maxStepLength : CGFloat = 0.05</span><br><span class="line">        /// 键值</span><br><span class="line">        static var keyPathsContentOffset = &quot;contentOffset&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 刷新事件</span><br><span class="line">    var actionClosure : (()-&gt;())?</span><br><span class="line">    /// 顶部波浪颜色</span><br><span class="line">    var topWaveColor : UIColor? &#123;</span><br><span class="line">        willSet&#123;</span><br><span class="line">            firstWaveLayer.fillColor = newValue!.cgColor</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 底部波浪颜色</span><br><span class="line">    var bottomWaveColor : UIColor? &#123;</span><br><span class="line">        willSet&#123;</span><br><span class="line">            secondWaveLayer.fillColor = newValue!.cgColor</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 对应scrollView</span><br><span class="line">    fileprivate weak var scrollView : UIScrollView?&#123;</span><br><span class="line">        willSet&#123;</span><br><span class="line">            _cycle = CGFloat(2 * M_PI) / newValue!.frame.size.width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// 定时器</span><br><span class="line">    fileprivate var displaylink : CADisplayLink!</span><br><span class="line">    /// 顶部波浪</span><br><span class="line">    fileprivate var firstWaveLayer : CAShapeLayer!</span><br><span class="line">    /// 底部波浪</span><br><span class="line">    fileprivate var secondWaveLayer : CAShapeLayer!</span><br><span class="line">    /// 状态</span><br><span class="line">    fileprivate var state : WaveRefreshViewState! = .stop</span><br><span class="line">    /// 根据scrollView偏移量得出的比例</span><br><span class="line">    fileprivate var _times : NSInteger = 0</span><br><span class="line">    /// 波峰值</span><br><span class="line">    fileprivate var _amplitude : CGFloat = 0</span><br><span class="line">    /// 波浪的周期值</span><br><span class="line">    fileprivate var _cycle : CGFloat = 0</span><br><span class="line">    /// 单位时间平移速率</span><br><span class="line">    fileprivate var _speed : CGFloat = 0</span><br><span class="line">    /// 波浪平移偏移量</span><br><span class="line">    fileprivate var _offsetX : CGFloat = 0</span><br><span class="line">    /// scrollView偏移量</span><br><span class="line">    fileprivate var _offsetY : CGFloat = 0</span><br><span class="line">    /// 计算波峰的比率</span><br><span class="line">    fileprivate var _variable : CGFloat = 0</span><br><span class="line">    /// 波峰至波谷的距离</span><br><span class="line">    fileprivate var _height : CGFloat = 0</span><br><span class="line">    /// 波峰是否增大</span><br><span class="line">    fileprivate var _increase  : Bool = false</span><br></pre></td></tr></table></figure><h4 id="绘制曲线"><a href="#绘制曲线" class="headerlink" title="绘制曲线"></a>绘制曲线</h4><p>如果要根据函数绘制曲线，我们需要设置各个值<br>初相位设置为0<br>周期设置为2π<br>波峰设置为1<br>位移设置为0<br>然后根据y = sin(x)计算出点的坐标然后使用<code>CGMutablePath</code>对象的<code>addLine</code>方法连线得出最后路径</p><h4 id="由静态到动态"><a href="#由静态到动态" class="headerlink" title="由静态到动态"></a>由静态到动态</h4><p>我们已经绘制了一条静态的曲线，我们通过什么方法来让它变成动态的呢？我们看上面各个值的定义，我们通过初相位来让曲线左右平移，我们需要通过定时器来让初相位根据时间进行线性的变化，我们设置单位时间的初相位的变化值为<code>π/2</code>,因为函数的周期为<code>2π</code>，4个单位时间为一个周期，我们可以通过改变这个变量来控制波浪平移的速度<br>顶部波浪的刷新方法,<code>firstWaveLayer</code>已创建好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func configFirstWaveLayerPath() -&gt; Void &#123;</span><br><span class="line">        guard let scrollView = scrollView else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var y = _offsetY</span><br><span class="line">        let path : CGMutablePath = CGMutablePath()</span><br><span class="line">        path.move(to: CGPoint(x: 0, y: y))</span><br><span class="line">        let waveWidth : CGFloat = scrollView.frame.size.width</span><br><span class="line">        for x in 0...Int(waveWidth) &#123;</span><br><span class="line">            y = _amplitude * sin(_cycle * CGFloat(x) + _offsetX) + _offsetY</span><br><span class="line">            path.addLine(to: CGPoint(x: CGFloat(x), y: y))</span><br><span class="line">        &#125;</span><br><span class="line">        path.addLine(to: CGPoint(x: waveWidth, y: self.frame.size.height))</span><br><span class="line">        path.addLine(to: CGPoint(x: 0, y: self.frame.size.height))</span><br><span class="line">        path.closeSubpath()</span><br><span class="line">        firstWaveLayer.path = path</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>顶部波浪的刷新方法,<code>secondWaveLayer</code>已创建好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func configSecondWaveLayerPath() -&gt; Void &#123;</span><br><span class="line">    guard let scrollView = scrollView else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var y = _offsetY</span><br><span class="line">    let path = CGMutablePath()</span><br><span class="line">    path.move(to: CGPoint(x: 0, y: y))</span><br><span class="line">    let forward = CGFloat(M_PI) / (_cycle * 4.0)</span><br><span class="line">    let waveWidth : CGFloat = scrollView.frame.size.width</span><br><span class="line">    for x in 0...Int(waveWidth) &#123;</span><br><span class="line">        y = _amplitude * cos(_cycle * CGFloat(x) + _offsetX  + forward) + _offsetY</span><br><span class="line">        path.addLine(to: CGPoint(x: CGFloat(x), y: y))</span><br><span class="line">    &#125;</span><br><span class="line">    path.addLine(to: CGPoint(x: waveWidth, y: self.frame.size.height))</span><br><span class="line">    path.addLine(to: CGPoint(x: 0, y: self.frame.size.height))</span><br><span class="line">    path.closeSubpath()</span><br><span class="line">    secondWaveLayer.path = path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="调整两个波浪的偏移量"><a href="#调整两个波浪的偏移量" class="headerlink" title="调整两个波浪的偏移量"></a>调整两个波浪的偏移量</h4><p>我们其中一个是<code>sin</code>和<code>cos</code>函数，由上图可见两个曲线错位了1/8个周期，我们如果要让上下对称需要将<code>cos</code>函数加1/4的个周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let forward = CGFloat(M_PI) / (_cycle * 4.0)</span><br></pre></td></tr></table></figure><h4 id="刷新波峰"><a href="#刷新波峰" class="headerlink" title="刷新波峰"></a>刷新波峰</h4><p>通过_increase属性交替来改变波峰的值，增长到最大时候开始减小，减小到最小的开始增大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func configWaveAmplitude() -&gt; Void &#123;</span><br><span class="line">        if (_increase) &#123;</span><br><span class="line">            _variable += BingoWaveRefreshViewData.minStepLength</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let minus : CGFloat = self.state == .animatingToStopped ? BingoWaveRefreshViewData.maxStepLength : BingoWaveRefreshViewData.minStepLength</span><br><span class="line">            _variable -= minus;</span><br><span class="line">            if (_variable &lt;= 0.00) &#123;</span><br><span class="line">                self.stopWave()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (_variable &lt;= BingoWaveRefreshViewData.minVariable) &#123;</span><br><span class="line">            _increase = !(self.state == .animatingToStopped)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (_variable &gt;= BingoWaveRefreshViewData.maxVariable) &#123;</span><br><span class="line">            _increase = false</span><br><span class="line">        &#125;</span><br><span class="line">        // self.amplitude = self.variable*self.times;</span><br><span class="line">        if (_times &gt;= 7) &#123;</span><br><span class="line">            _times = 7;</span><br><span class="line">        &#125;</span><br><span class="line">        _amplitude = _variable * CGFloat( _times)</span><br><span class="line">        _height = BingoWaveRefreshViewData.maxVariable * CGFloat( _times)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h4><p>监听<code>scrollView.contentOffset</code>的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123;</span><br><span class="line">    if scrollView == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if let keyPath = keyPath &#123;</span><br><span class="line">        switch keyPath &#123;</span><br><span class="line">        case BingoWaveRefreshViewData.keyPathsContentOffset:</span><br><span class="line">            didChangeContentOffset()</span><br><span class="line">        default:</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func observe(scrollView : UIScrollView) -&gt; Void &#123;</span><br><span class="line">    self.scrollView = scrollView</span><br><span class="line">    self.scrollView?.addObserver(self, forKeyPath: BingoWaveRefreshViewData.keyPathsContentOffset, options: .new, context: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主要波浪处理部分大致就这些，构建时使用runtime来为scrollView动态增加属性，具体请在具体项目中查看，文档覆盖率比较高"><a href="#主要波浪处理部分大致就这些，构建时使用runtime来为scrollView动态增加属性，具体请在具体项目中查看，文档覆盖率比较高" class="headerlink" title="主要波浪处理部分大致就这些，构建时使用runtime来为scrollView动态增加属性，具体请在具体项目中查看，文档覆盖率比较高"></a>主要波浪处理部分大致就这些，构建时使用<code>runtime</code>来为<code>scrollView</code>动态增加属性，具体请在具体项目中查看，文档覆盖率比较高</h5><hr><h4 id="最后，po出项目地址，可以直接使用WaveRefreshView"><a href="#最后，po出项目地址，可以直接使用WaveRefreshView" class="headerlink" title="最后，po出项目地址，可以直接使用WaveRefreshView"></a>最后，po出项目地址，可以直接使用<a href="https://github.com/2016321/WaveRefreshView" target="_blank" rel="noopener">WaveRefreshView</a></h4><h4 id="希望可以帮助到大家，如果有更优的方法请留言或私信交流"><a href="#希望可以帮助到大家，如果有更优的方法请留言或私信交流" class="headerlink" title="希望可以帮助到大家，如果有更优的方法请留言或私信交流"></a>希望可以帮助到大家，如果有更优的方法请留言或私信交流</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点&quot;&gt;&lt;a href=&quot;#我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点&quot; class=&quot;headerlink&quot; title=&quot;我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点&quot;&gt;&lt;/a&gt;我们先看一下效果，现在很多app有这种交互，普通的下拉刷新有点low，这样感觉酷炫一点&lt;/h3&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView 加载html字符串时取消缩放</title>
    <link href="http://yoursite.com/2017/05/19/WKWebView-%E5%8A%A0%E8%BD%BDhtml%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E5%8F%96%E6%B6%88%E7%BC%A9%E6%94%BE/"/>
    <id>http://yoursite.com/2017/05/19/WKWebView-加载html字符串时取消缩放/</id>
    <published>2017-05-19T08:23:01.000Z</published>
    <updated>2018-07-02T10:41:46.140Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继上次的WKWebview的坑今天又遇到了一个，因为我需要监听WebView的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。"><a href="#继上次的WKWebview的坑今天又遇到了一个，因为我需要监听WebView的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。" class="headerlink" title="继上次的WKWebview的坑今天又遇到了一个，因为我需要监听WebView的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。"></a>继上次的<code>WKWebview</code>的坑今天又遇到了一个，因为我需要监听<code>WebView</code>的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。</h3><a id="more"></a><p>有的朋友会想，直接在<code>scrollView</code>的代理中关闭就可以了，然而不是这个样子的，其实在<code>webView.scrollView</code>上面还有一个渲染层，缩放是在这个渲染层上面进行的，但是缩放的过程中如果超出<code>webView</code>的边界时候会让<code>ScrollView</code>进行滚动,所以需要在代码层面上禁止缩放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=\&quot;viewport\&quot; content=\&quot;user-scalable=no\&quot; &gt;</span><br></pre></td></tr></table></figure></p><p>在加载的字符串前面拼接一个<code>&lt;meta&gt;</code>标签禁止缩放</p><hr><h4 id="网上的WKWebView相关坑的文章还是比较少得，都是一些基础使用的文章，大同小异，后期会出一个关于WKWebView的专题深入的谈谈WKWebView"><a href="#网上的WKWebView相关坑的文章还是比较少得，都是一些基础使用的文章，大同小异，后期会出一个关于WKWebView的专题深入的谈谈WKWebView" class="headerlink" title="网上的WKWebView相关坑的文章还是比较少得，都是一些基础使用的文章，大同小异，后期会出一个关于WKWebView的专题深入的谈谈WKWebView"></a>网上的WKWebView相关坑的文章还是比较少得，都是一些基础使用的文章，大同小异，后期会出一个关于WKWebView的专题深入的谈谈WKWebView</h4><h5 id="希望我的文章能帮助大家"><a href="#希望我的文章能帮助大家" class="headerlink" title="希望我的文章能帮助大家"></a>希望我的文章能帮助大家</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;继上次的WKWebview的坑今天又遇到了一个，因为我需要监听WebView的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。&quot;&gt;&lt;a href=&quot;#继上次的WKWebview的坑今天又遇到了一个，因为我需要监听WebView的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。&quot; class=&quot;headerlink&quot; title=&quot;继上次的WKWebview的坑今天又遇到了一个，因为我需要监听WebView的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。&quot;&gt;&lt;/a&gt;继上次的&lt;code&gt;WKWebview&lt;/code&gt;的坑今天又遇到了一个，因为我需要监听&lt;code&gt;WebView&lt;/code&gt;的滚动，在缩放时候会对参数造成影响，同时用户体验也不好，给人一种不连贯的感觉。。。&lt;/h3&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView加载HTML字符串 获取高度渲染高度</title>
    <link href="http://yoursite.com/2017/05/18/WKWebView%E5%8A%A0%E8%BD%BDHTML%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%8E%B7%E5%8F%96%E9%AB%98%E5%BA%A6%E6%B8%B2%E6%9F%93%E9%AB%98%E5%BA%A6/"/>
    <id>http://yoursite.com/2017/05/18/WKWebView加载HTML字符串-获取高度渲染高度/</id>
    <published>2017-05-17T16:24:24.000Z</published>
    <updated>2018-07-02T10:41:54.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面"><a href="#这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面" class="headerlink" title="这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面"></a>这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面</h3><a id="more"></a><h4 id="具体的需求是这样子的，简书APP文章详情页面。。。应设计师要求我就不po图了，可以打开看一下简书APP。。。"><a href="#具体的需求是这样子的，简书APP文章详情页面。。。应设计师要求我就不po图了，可以打开看一下简书APP。。。" class="headerlink" title="具体的需求是这样子的，简书APP文章详情页面。。。应设计师要求我就不po图了，可以打开看一下简书APP。。。"></a>具体的需求是这样子的，简书APP文章详情页面。。。应设计师要求我就不po图了，可以打开看一下简书APP。。。</h4><p>大致就是这样子有一个下拉可以放大上划<code>navigationBar</code>淡出的交互的头图，下面接着是一个需要加载html字符串的<code>WKWebView</code>(这里为什么用WK,大家都知道<code>UIWebView</code>的内存损耗简直爆炸，而且我们的项目是适配iOS8以上，所以当然是最佳之选)，下面还要有一个<code>UITableView</code>来展示专题的评论，很像简书有木有。。。</p><p>我大致就是这样处理的，将<code>WKWebView.scrollView</code>的<code>contentInset</code>属性的<code>top</code>值设置为图片的高度，然后将图片视图加到<code>WKWebView.scrollView</code>上面，然后将整个一个<code>WkWebView</code>作为头视图加到<code>UITableView</code>上面，这样就不用处理因为多层<code>scrollView</code>嵌套而带来的手势冲突。</p><hr><h4 id="下面讲讲WKWebView的处理"><a href="#下面讲讲WKWebView的处理" class="headerlink" title="下面讲讲WKWebView的处理"></a>下面讲讲<code>WKWebView</code>的处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p.p1 &#123;margin: 0.0px 0.0px 0.0px 0.0px; line-height: 19.0px; font: 13.0px &apos;Helvetica Neue&apos;&#125;p.p2 &#123;margin: 0.0px 0.0px 0.0px 0.0px; line-height: 19.0px; font: 14.0px &apos;Helvetica Neue&apos;&#125;span.s1 &#123;font: 13.0px &apos;Helvetica Neue&apos;&#125;span.s2 &#123;color: #00a2ff&#125;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line"> &lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot; style=&quot;text-align:center;&quot;&gt;</span><br><span class="line">  &lt;br /&gt;</span><br><span class="line"> &lt;/p &gt;</span><br><span class="line"> &lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot; style=&quot;text-align:center;&quot;&gt;</span><br><span class="line">  各位小伙伴们，大家都听说过创新工场这家机构吗？在创投圈，创新工场应该是耳熟能详的一个名字了。创新工场是一家早期投资机构投资机构。所谓投资机构，全称风险投资机构（VC），风险投资机构是风险投资最直接的参与者和实际操作者，同时也最直接地承受风险、分享收益。简单来说就是会为创业者提供融资的来源之一。</span><br><span class="line"> &lt;/p &gt;</span><br><span class="line"> &lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot; style=&quot;text-align:center;&quot;&gt;</span><br><span class="line">  &lt; img width=&quot;1920&quot; height=&quot;480&quot; src=&quot;http://oli02rut3.bkt.clouddn.com/201702171256554KSruA0R.jpg&quot; alt=&quot;&quot; title=&quot;&quot; align=&quot;&quot; /&gt;</span><br><span class="line"> &lt;/p &gt;</span><br><span class="line"> &lt;p class=&quot;MsoNormal&quot;&gt;</span><br><span class="line">  &amp;nbsp;</span><br><span class="line"> &lt;/p &gt;</span><br><span class="line"> &lt;p class=&quot;MsoNormal&quot;&gt;</span><br><span class="line">  如果没听说过创新工场这个名字的话，那么李开复这个名字应该听说过吧，李开复就是创新工场的创始人了。如果你连李开复都没有听说过的话，那么你肯定用过知乎吧，就算你没用过，你也应该听说过知乎吧，知乎是创新工场投过的一个成功的投资案例了。</span><br><span class="line"> &lt;/p &gt;</span><br><span class="line">&lt;/p &gt;</span><br></pre></td></tr></table></figure><p>以上就是后台传过来的数据，看到这个得我是这样的</p><p><img src="https://s6.postimg.cc/8a3fkyo29/2353844-14fc2f98ca0ca62c.png" alt="Paste_Image.png"></p><p>让我加载个这东西？<br>果然，第一个出问题的是图片，这个图片让我想起了iPhone20</p><p><img src="https://s6.postimg.cc/9cdm3ield/2353844-111c82673a24fb3d.png" alt="Paste_Image.png"></p><p>废话不多说，我将HTML代码处理的一下，结果是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let html = &quot;&lt;div id = \&quot;content\&quot;&gt;&lt;style type=\&quot;text/css\&quot;&gt;img&#123;width : 100% ; height : auto; display: block;&#125;&lt;/style&gt;\(result)&lt;/div&gt;&quot;</span><br></pre></td></tr></table></figure><p>首先先用一个<code>div</code>将其包起来，起一个自己比较喜欢的<code>id</code><br>里面写一个样式让图片自适应屏幕宽的100%(加载出来不是iPhone的屏宽，左右有一点留白)，高度根据原有的长宽比会自适应，高高兴兴的加载了出来发现图片正常了，但因为我们的html字符串加载不满一屏下面有一大片留白，如果运营M(zu)M(zong)那天不想写，直接一个图几句话我下面一大片空白就醉了，首先我们需要写一点js获取一下加载后的高度，直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//需要设置代理处理webView加载完成之后的状态</span><br><span class="line">webView.navigationDelegate = self</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extension SubjectDetailViewController : WKNavigationDelegate&#123;</span><br><span class="line">    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123;</span><br><span class="line">        webView.evaluateJavaScript(&quot;document.getElementById(\&quot;content\&quot;).offsetHeight;&quot;) &#123; (result, error) in</span><br><span class="line">            if let webViewHeight = result as? CGFloat&#123;</span><br><span class="line">                var frame = webView.frame</span><br><span class="line">                let height = webViewHeight / 3 + UIScreen.screenWidth() * 38 / 75</span><br><span class="line">                frame.size.height = height</span><br><span class="line">                if height &gt; UIScreen.screenHeight() - 49&#123;</span><br><span class="line">                    webView.scrollView.isScrollEnabled = true</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    webView.frame = frame</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是这段<code>&quot;document.getElementById(\&quot;content\&quot;).offsetHeight;&quot;)</code>，获取的是<code>content</code>标签中代码加载后的滚动范围，在执行后返回的高度的单位不知道是什么，5s中半屏的区域返回了1000左右，可能是px，经过多次尝试之后发现返回的高度和苹果的pt是1:3的关系</p><p>之后的判断是高度是否大于屏高减去tabbar的高度，也就是屏幕的最大显示范围，大于的时候开启<code>WKWebView.scrollView</code>的滑动功能，当小于的时候也就是不满一屏，直接重置webView的<code>frame.size.height</code>并关闭滑动手势，这样一来下面的留白就没有了，就像是简书APP的文章详情一样，但是在webView超过一屏的时候，从webView到评论列表会有一个手势转化上的卡顿，几乎没有对用户造成影响</p><h3 id="这是我遇到这个问题处理的方法，如果有更好的方法希望可以互相交流一下，希望这个思路可以帮到大家"><a href="#这是我遇到这个问题处理的方法，如果有更好的方法希望可以互相交流一下，希望这个思路可以帮到大家" class="headerlink" title="这是我遇到这个问题处理的方法，如果有更好的方法希望可以互相交流一下，希望这个思路可以帮到大家"></a>这是我遇到这个问题处理的方法，如果有更好的方法希望可以互相交流一下，希望这个思路可以帮到大家</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面&quot;&gt;&lt;a href=&quot;#这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面&quot; class=&quot;headerlink&quot; title=&quot;这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面&quot;&gt;&lt;/a&gt;这篇文章算是个小记，可能只会暂时描述问题和解决问题方法，原理的方面之后具体写在Diary里面&lt;/h3&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 使用runtime给extension添加属性</title>
    <link href="http://yoursite.com/2017/05/15/Swift-%E4%BD%BF%E7%94%A8runtime%E7%BB%99extension%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/05/15/Swift-使用runtime给extension添加属性/</id>
    <published>2017-05-15T07:18:43.000Z</published>
    <updated>2018-07-02T10:42:04.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用swift写新项目，也算是试水，虽然现在swift算是推广起来了，很多大厂小公司的新项目都是swift，但是还是不少坑，这两天写一个waveView就遇到了个这个问题</p><a id="more"></a><hr><p>一般再OC中使用runtime给分类添加属性是这个样子的<code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSomeProperty:(NSString *)someProperty&#123;</span><br><span class="line">    objc_setAssociatedObject(self, Key, @(quickTapEnable), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)someProperty&#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, Key) boolValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了看之前写过的OC代码，微微一笑，写出了这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var refreshView : WaveView&#123;</span><br><span class="line">        set&#123;</span><br><span class="line">            objc_setAssociatedObject(self, &quot;key&quot;, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br><span class="line">        &#125;</span><br><span class="line">        get&#123;</span><br><span class="line">            return objc_getAssociatedObject(self, &quot;key&quot;) as! WaveView</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s6.postimg.cc/uysmkev4h/2353844-6c626fdfe4fff158.png" alt="Paste_Image.png"></p><p>然后用了一下这个这几行检验一下，果然没存进去。。。</p><p>我们看一下<code>objc_setAssociatedObject</code>的API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Sets an associated value for a given object using a given key and association policy.</span><br><span class="line"> * </span><br><span class="line"> * @param object The source object for the association.</span><br><span class="line"> * @param key The key for the association.</span><br><span class="line"> * @param value The value to associate with the key key for object. Pass nil to clear an existing association.</span><br><span class="line"> * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.”</span><br><span class="line"> * </span><br><span class="line"> * @see objc_setAssociatedObject</span><br><span class="line"> * @see objc_removeAssociatedObjects</span><br><span class="line"> */</span><br><span class="line">@available(iOS 3.1, *)</span><br><span class="line">public func objc_setAssociatedObject(_ object: Any!, _ key: UnsafeRawPointer!, _ value: Any!, _ policy: objc_AssociationPolicy)</span><br></pre></td></tr></table></figure></p><p>第二个参数是<code>UnsafeRawPointer</code>结构体指针类型，Swift并不推荐对指针进行直接操作,  但仍提供了几种可以直接操作内存的指针类型，在Swift中无类型的指针，原始内存可以用<code>UnsafeRawPointer</code> 和<code>UnsafeMutableRawPointer</code>来表示</p><p>我们看一下<code>UnsafeRawPointer</code>的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// Converts a pattern of bits to an `UnsafeRawPointer`.</span><br><span class="line">///</span><br><span class="line">/// Returns `nil` if `bitPattern` is zero.</span><br><span class="line">public init?(bitPattern: Int)</span><br><span class="line"></span><br><span class="line">/// Converts a pattern of bits to an `UnsafeRawPointer`.</span><br><span class="line">///</span><br><span class="line">/// Returns `nil` if `bitPattern` is zero.</span><br><span class="line">public init?(bitPattern: UInt)</span><br></pre></td></tr></table></figure><p>要想通过字符串生成意义对应的<code>Int</code>值，我们可以使用</p><p><code>&quot;key&quot;.hashValue</code>的形式将字符串生成哈希值来返回<code>Int</code>值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var refreshView : WaveView? &#123;</span><br><span class="line">        set&#123;</span><br><span class="line">            let key: UnsafeRawPointer! = UnsafeRawPointer(bitPattern: &quot;key&quot;.hashValue)</span><br><span class="line">            objc_setAssociatedObject(self, key, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">        &#125;</span><br><span class="line">        get&#123;</span><br><span class="line">            let key: UnsafeRawPointer! = UnsafeRawPointer(bitPattern: &quot;key&quot;.hashValue)</span><br><span class="line">            return objc_getAssociatedObject(self, key) as? WaveView</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://s6.postimg.cc/jmg12p70x/2353844-386797e118259d27.png" alt="Paste_Image.png"></p><p>这种方法完美解决了解包失败</p><hr><p>因为是经常使用的<code>key</code>值，我们应该一次定义多次调用，避免这样重复写好多次,如同在配置文件里面定义全局通知的标识符一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let key = UnsafeRawPointer(bitPattern: &quot;key&quot;.hashValue)</span><br></pre></td></tr></table></figure></p><h3 id="希望这篇文章可以帮到大家"><a href="#希望这篇文章可以帮到大家" class="headerlink" title="希望这篇文章可以帮到大家"></a>希望这篇文章可以帮到大家</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用swift写新项目，也算是试水，虽然现在swift算是推广起来了，很多大厂小公司的新项目都是swift，但是还是不少坑，这两天写一个waveView就遇到了个这个问题&lt;/p&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 移除所有子视图</title>
    <link href="http://yoursite.com/2017/05/09/iOS-%E7%A7%BB%E9%99%A4%E6%89%80%E6%9C%89%E5%AD%90%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/05/09/iOS-移除所有子视图/</id>
    <published>2017-05-09T02:22:59.000Z</published>
    <updated>2018-07-02T10:42:53.200Z</updated>
    
    <content type="html"><![CDATA[<h5 id="有的时候我们会有这样的需求，就是移除所有子视图"><a href="#有的时候我们会有这样的需求，就是移除所有子视图" class="headerlink" title="有的时候我们会有这样的需求，就是移除所有子视图"></a>有的时候我们会有这样的需求，就是移除所有子视图</h5><a id="more"></a><p>实际上就是NSArray中遍历元素的方法，如果使用<code>for...in</code>遍历的话有点低级,我们可以使用NSArray的makeObjectsPerformSelector方法遍历元素响应<code>removeFromSuperview</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];</span><br></pre></td></tr></table></figure></p><p>或者，使用枚举器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[self.view subviews] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;  </span><br><span class="line">        [(UIView*)obj removeFromSuperview];  </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p><p>但是在<code>swift</code>中<code>subviews</code>是<code>Array</code>类型，由于较之<code>NSArray</code>类型<code>swift</code>中的<code>Array</code>类型要弱化好多</p><p><img src="https://s6.postimg.cc/iwx8q5r01/5x_Wz.png" alt="Paste_Image.png"></p><p>并没有<code>makeObjectsPerformSelector</code>和<code>枚举器</code>这两个方法<br>，我们可以使用高阶map函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.subviews.map&#123;$0.removeFromSuperview()&#125;</span><br></pre></td></tr></table></figure></p><p>因为map返回一个<code>&lt;T&gt;</code>类型,这样写出会报<code>unused</code>的警告，代码洁癖的可以这样写。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = view.subviews.map&#123;$0.removeFromSuperview()&#125;</span><br></pre></td></tr></table></figure></p><h2 id="每日一记，希望能帮助大家-。"><a href="#每日一记，希望能帮助大家-。" class="headerlink" title="每日一记，希望能帮助大家 ~。~"></a>每日一记，希望能帮助大家 ~。~</h2>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;有的时候我们会有这样的需求，就是移除所有子视图&quot;&gt;&lt;a href=&quot;#有的时候我们会有这样的需求，就是移除所有子视图&quot; class=&quot;headerlink&quot; title=&quot;有的时候我们会有这样的需求，就是移除所有子视图&quot;&gt;&lt;/a&gt;有的时候我们会有这样的需求，就是移除所有子视图&lt;/h5&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使用runtime进行解档和归档</title>
    <link href="http://yoursite.com/2017/04/15/%E4%BD%BF%E7%94%A8runtime%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%A1%A3%E5%92%8C%E5%BD%92%E6%A1%A3/"/>
    <id>http://yoursite.com/2017/04/15/使用runtime进行解档和归档/</id>
    <published>2017-04-15T14:35:36.000Z</published>
    <updated>2018-07-02T10:43:08.797Z</updated>
    
    <content type="html"><![CDATA[<h4 id="首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下-，要不然别人怎么知道你会😂😂"><a href="#首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下-，要不然别人怎么知道你会😂😂" class="headerlink" title="首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下*，要不然别人怎么知道你会😂😂"></a>首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下*，要不然别人怎么知道你会😂😂</h4><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 归档</span><br><span class="line">func encodeWithCoder(aCoder: NSCoder) &#123;</span><br><span class="line">    aCoder.encodeObject(name, forKey: &quot;name&quot;)</span><br><span class="line">    aCoder.encodeObject(age, forKey: &quot;age&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 解档</span><br><span class="line">required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    super.init()</span><br><span class="line">    name = aDecoder.decodeObjectForKey(&quot;name&quot;) as? String</span><br><span class="line">    age = aDecoder.decodeObjectForKey(&quot;age&quot;) as? Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="帅气的扶了扶眼镜，大家注意，我要开始装-了"><a href="#帅气的扶了扶眼镜，大家注意，我要开始装-了" class="headerlink" title="帅气的扶了扶眼镜，大家注意，我要开始装*了"></a>帅气的扶了扶眼镜，大家注意，我要开始装*了</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Model: NSObject, NSCoding &#123;</span><br><span class="line">    dynamic var name = &quot;&quot;</span><br><span class="line">    dynamic var age = 0</span><br><span class="line">    override init() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    // 归档</span><br><span class="line">    func encode(with aCoder: NSCoder) &#123;</span><br><span class="line">        var count: UInt32 = 0</span><br><span class="line">        guard let ivars = class_copyIvarList(self.classForCoder, &amp;count) else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for i in 0 ..&lt; count &#123;</span><br><span class="line">            let ivar = ivars[Int(i)]</span><br><span class="line">            let name = ivar_getName(ivar)</span><br><span class="line">            </span><br><span class="line">            let key = NSString.init(utf8String: name!) as! String</span><br><span class="line">            </span><br><span class="line">            if let value = self.value(forKey: key) &#123;</span><br><span class="line">                aCoder.encode(value, forKey: key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars)</span><br><span class="line">    &#125;</span><br><span class="line">    // 解档</span><br><span class="line">    required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        var count: UInt32 = 0</span><br><span class="line">        guard let ivars = class_copyIvarList(self.classForCoder, &amp;count) else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for i in 0 ..&lt; count &#123;</span><br><span class="line">            let ivar = ivars[Int(i)]</span><br><span class="line">            let name = ivar_getName(ivar)</span><br><span class="line">            let key = NSString.init(utf8String: name!) as! String</span><br><span class="line">            if let value = aDecoder.decodeObject(forKey: key) &#123;</span><br><span class="line">                self.setValue(value, forKey: key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用runtime解档归档的时候一定要在属性前加上<code>dynamic</code>关键字,并且不能使用可选属性*</li></ul><p>######下面我们准备一下要归档的模型和文件路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let model = Model()</span><br><span class="line">model.name = &quot;FlyChang&quot;</span><br><span class="line">model.age = 25</span><br><span class="line">var path = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).last</span><br><span class="line">path = path! + &quot;/Model&quot;</span><br></pre></td></tr></table></figure></p><h6 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let data = NSMutableData()</span><br><span class="line">let archiver = NSKeyedArchiver(forWritingWith: data)</span><br><span class="line">archiver.encode(model, forKey: &quot;model&quot;)</span><br><span class="line">archiver.finishEncoding()</span><br><span class="line">data.write(toFile: path!, atomically: true)</span><br></pre></td></tr></table></figure><h6 id="解档"><a href="#解档" class="headerlink" title="解档"></a>解档</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let data = NSData(contentsOfFile: path!)</span><br><span class="line">let unarchiver = NSKeyedUnarchiver(forReadingWith: data)</span><br><span class="line">let model = unarchiver.decodeObject(forKey: &quot;model&quot;) as! Model</span><br><span class="line">unarchiver.finishDecoding()</span><br></pre></td></tr></table></figure><h4 id="总结了一下使用runtime归档解档的方法，希望能给大家带来帮助"><a href="#总结了一下使用runtime归档解档的方法，希望能给大家带来帮助" class="headerlink" title="总结了一下使用runtime归档解档的方法，希望能给大家带来帮助~"></a>总结了一下使用runtime归档解档的方法，希望能给大家带来帮助~</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下-，要不然别人怎么知道你会😂😂&quot;&gt;&lt;a href=&quot;#首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下-，要不然别人怎么知道你会😂😂&quot; class=&quot;headerlink&quot; title=&quot;首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下*，要不然别人怎么知道你会😂😂&quot;&gt;&lt;/a&gt;首先我们先看一下不用runtime的写法，大家可能感觉很简单为什么要用runtime来实现，但是试想一下如果一个对象有很多很多的属性，我们还要一行一行写吗，和从json中给模型赋值一个道理，还是要用runtime装一下*，要不然别人怎么知道你会😂😂&lt;/h4&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使用runtime防止Button暴力点击</title>
    <link href="http://yoursite.com/2017/04/05/%E4%BD%BF%E7%94%A8runtime%E9%98%B2%E6%AD%A2Button%E6%9A%B4%E5%8A%9B%E7%82%B9%E5%87%BB/"/>
    <id>http://yoursite.com/2017/04/05/使用runtime防止Button暴力点击/</id>
    <published>2017-04-05T12:08:19.000Z</published>
    <updated>2018-07-02T10:43:12.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。"><a href="#按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。" class="headerlink" title="按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。"></a>按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。</h3><a id="more"></a><p><em>一言不合上代码</em></p><h5 id="首先在按钮的extension里面加入一个结构体和两个计算型属性，结构体记录string常量"><a href="#首先在按钮的extension里面加入一个结构体和两个计算型属性，结构体记录string常量" class="headerlink" title="首先在按钮的extension里面加入一个结构体和两个计算型属性，结构体记录string常量"></a>首先在按钮的extension里面加入一个结构体和两个计算型属性，结构体记录string常量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private struct AssociatedKeys &#123;</span><br><span class="line">    static var acceptEventInterval  = &quot;acceptEventInterval&quot;</span><br><span class="line">    static var waitingTime          = &quot;waitingTime&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acceptEventInterval</code>用来记录点击间隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// 按钮点击间隔时间</span><br><span class="line">public var acceptEventInterval: TimeInterval &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        if let acceptEventInterval = objc_getAssociatedObject(self, &amp;AssociatedKeys.acceptEventInterval) as? TimeInterval &#123;</span><br><span class="line">            return acceptEventInterval</span><br><span class="line">        &#125;</span><br><span class="line">        return 0.0</span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">        assert(newValue &gt; 0, &quot;acceptEventInterval should be valid&quot;)</span><br><span class="line">        methodSwizzling()</span><br><span class="line">        objc_setAssociatedObject(self,</span><br><span class="line">                                 &amp;AssociatedKeys.acceptEventInterval,</span><br><span class="line">                                 newValue,</span><br><span class="line">                                 .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitingTime</code>用来记录上次有效点击的时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">/// 当前等待时间</span><br><span class="line">private var waitingTime: TimeInterval &#123;</span><br><span class="line">get &#123;</span><br><span class="line">if let waitingTime = objc_getAssociatedObject(self, &amp;AssociatedKeys.waitingTime) as? TimeInterval &#123;</span><br><span class="line">return waitingTime</span><br><span class="line">&#125;</span><br><span class="line">return 0.0</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">objc_setAssociatedObject(self,&amp;AssociatedKeys.waitingTime,newValue,.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>交换点击方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// 交换方法</span><br><span class="line">private func methodSwizzling() &#123;</span><br><span class="line">let before: Method  = class_getInstanceMethod(self.classForCoder, #selector(self.sendAction(_:to:for:)))</span><br><span class="line">let after: Method   = class_getInstanceMethod(self.classForCoder, #selector(self._sendAction(_:to:for:)))</span><br><span class="line">method_exchangeImplementations(before, after)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击方法的替换方法，判断当前时间戳减去上次有效点击的时间戳的间隔时间是否小于设置的间隔时长，小于则直接返回，如果大于等于则判定为有效点击，记录时间戳并执行点击方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 点击判断方法</span><br><span class="line">///</span><br><span class="line">/// - Parameters:</span><br><span class="line">///   - action: action description</span><br><span class="line">///   - target: target description</span><br><span class="line">///   - event: event description</span><br><span class="line">@objc private func _sendAction(_ action: Selector, to target: Any?, for event: UIEvent?) &#123;</span><br><span class="line">        if Date().timeIntervalSince1970 - waitingTime &lt; acceptEventInterval &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        waitingTime = Date().timeIntervalSince1970</span><br><span class="line">        sendAction(action, to: target, for: event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>acceptEventInterval</code>属性的set方法第一行有一个断言，当设置为小于或等于0时候就会触发断言(间隔时长无法设置为0或更小)，当newValue通过断言，交换响应方法，<code>objc_getAssociatedObject</code>使用给定的结构体的<code>acceptEventInterval</code>键动态增加关联值，get方法就是取出动态增加的关联值</p><h6 id="代码比较简单，这里就不上demo了，希望能帮助到大家"><a href="#代码比较简单，这里就不上demo了，希望能帮助到大家" class="headerlink" title="代码比较简单，这里就不上demo了，希望能帮助到大家"></a>代码比较简单，这里就不上demo了，希望能帮助到大家</h6>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。&quot;&gt;&lt;a href=&quot;#按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。&quot; class=&quot;headerlink&quot; title=&quot;按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。&quot;&gt;&lt;/a&gt;按钮防止暴力点击是个很平常的需求，测试时候产品经理、测试妹子经常会看哪个按钮不爽，然后使劲戳它，心疼按钮2秒钟。。。&lt;/h3&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>常用 GCD 笔记(OC / Swift)</title>
    <link href="http://yoursite.com/2017/03/28/%E5%B8%B8%E7%94%A8-GCD-%E7%AC%94%E8%AE%B0-OC-Swift/"/>
    <id>http://yoursite.com/2017/03/28/常用-GCD-笔记-OC-Swift/</id>
    <published>2017-03-28T11:53:58.000Z</published>
    <updated>2018-07-02T10:43:31.355Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-GCD简介"><a href="#1-GCD简介" class="headerlink" title="1. GCD简介"></a>1. GCD简介</h2><blockquote><p>什么是GCD呢？我们先来看看百度百科的解释简单了解下概念<br>引自<a href="https://baike.baidu.com/item/GCD" target="_blank" rel="noopener">百度百科</a>Grand Central Dispatch<br> (GCD) 是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p></blockquote><p><strong>为什么要用GCD呢？</strong><br>因为GCD有很多好处啊，具体如下：</p><ul><li>GCD可用于多核的并行运算</li><li>GCD会自动利用更多的CPU内核（比如双核、四核）</li><li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li></ul><h2 id="2-任务和队列"><a href="#2-任务和队列" class="headerlink" title="2. 任务和队列"></a>2. 任务和队列</h2><p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的。执行任务有两种方式：同步执行和异步执行。两者的主要区别是：是否具备开启新线程的能力。</p><ul><li>同步执行(sync)：只能在当前线程中执行任务，不具备开启新线程的能力</li><li>异步执行(async)：可以在新的线程中执行任务，具备开启新线程的能力</li></ul><p><strong>队列</strong>：这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：<strong>串行队列</strong>和<strong>并发队列</strong>。</p><ul><li>并发队列（Concurrent Dispatch Queue）：可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步（dispatch_async）函数下才有效</li><li>串行队列（Serial Dispatch Queue）：让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</li></ul><h2 id="3-GCD的使用"><a href="#3-GCD的使用" class="headerlink" title="3. GCD的使用"></a>3. GCD的使用</h2><h5 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h5><h6 id="串行并行队列"><a href="#串行并行队列" class="headerlink" title="串行并行队列"></a>串行并行队列</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// label:队列标签</span><br><span class="line">// qos:设置队列的优先级</span><br><span class="line">// attributes:队列形式：默认串行，设置为.concurrent代表是并行队列</span><br><span class="line">let queue = DispatchQueue(label: &quot;queue&quot;, qos: .default, attributes: .concurrent)</span><br><span class="line">//创建一个默认串行队列</span><br><span class="line">let queue = DispatchQueue(label: &quot;queue&quot;)</span><br><span class="line">//创建一个有优先级的串行队列</span><br><span class="line">let queue = DispatchQueue(label: &quot;queue&quot;, qos: .background)</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//参数1：队列的唯一标识符，用于DEBUG，可为空</span><br><span class="line">//参数2：用来识别是串行队列还是并发队列</span><br><span class="line">// 并发队列</span><br><span class="line">dispatch_queue_t queue= dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 串行队列</span><br><span class="line">dispatch_queue_t queue= dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure></p><h6 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 系统的全局队列</span><br><span class="line">let queue = DispatchQueue.global()</span><br><span class="line">let queue = DispatchQueue.global(qos: .default)</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//参数1：用来声明优先级</span><br><span class="line">//参数2：预留供将来使用，传递除零以外的任何值可能会导致空返回值，必须为0</span><br><span class="line">dispatch_queue_t queue0 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure></p><h5 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h5><p>我们先看一下这个表格，我们将按照这个表格顺序撰写一下示例代码</p><table><thead><tr><th></th><th>并发队列</th><th>串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步(sync)</td><td>没有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr><tr><td>异步(async)</td><td>有开启新线程，并发执行任务</td><td>有开启新线程(1条)，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr></tbody></table><h6 id="并行队列-同步执行"><a href="#并行队列-同步执行" class="headerlink" title="并行队列+同步执行"></a>并行队列+同步执行</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func syncConcurrent() -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">        print(&quot;syncConcurrent---begin&quot;)</span><br><span class="line">        </span><br><span class="line">        let queue = DispatchQueue(label: &quot;queue&quot;, attributes: .concurrent)</span><br><span class="line">        </span><br><span class="line">        queue.sync &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;111-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.sync &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;222-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.sync &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;333-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        print(&quot;syncConcurrent---end&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void) syncConcurrent&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue= dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;111------%@&quot; , [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;222------%@&quot; , [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;333------%@&quot; , [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>syncConcurrent—begin<br>111—–1–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>111—–2–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>111—–3–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>222—–1–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>222—–2–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>222—–3–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>333—–1–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>333—–2–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>333—–3–&lt;NSThread: 0x600000073780&gt;{number = 1, name = main}<br>syncConcurrent—end</p></blockquote><ul><li>打印信息显示，只有一个主线程执行任务，任务串行逐一执行<br>同时我们还可以看到，任务都在打印的begin和end间，说明任务是添加到队列中马上执行的。</li></ul><h6 id="并行队列-异步执行"><a href="#并行队列-异步执行" class="headerlink" title="并行队列+异步执行"></a>并行队列+异步执行</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func asyncConcurrent() -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">        print(&quot;syncConcurrent---begin&quot;)</span><br><span class="line">        </span><br><span class="line">        let queue = DispatchQueue(label: &quot;queue&quot;, attributes: .concurrent)</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;111-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;222-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;333-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        print(&quot;syncConcurrent---end&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void) asyncConcurrent&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue= dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;111------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;222------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;333------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>syncConcurrent—begin<br>syncConcurrent—end<br>111—–1–&lt;NSThread: 0x60000007b4c0&gt;{number = 3, name = (null)}<br>333—–1–&lt;NSThread: 0x60000007b380&gt;{number = 5, name = (null)}<br>222—–1–&lt;NSThread: 0x608000264e00&gt;{number = 4, name = (null)}<br>111—–2–&lt;NSThread: 0x60000007b4c0&gt;{number = 3, name = (null)}<br>222—–2–&lt;NSThread: 0x608000264e00&gt;{number = 4, name = (null)}<br>333—–2–&lt;NSThread: 0x60000007b380&gt;{number = 5, name = (null)}<br>111—–3–&lt;NSThread: 0x60000007b4c0&gt;{number = 3, name = (null)}<br>222—–3–&lt;NSThread: 0x608000264e00&gt;{number = 4, name = (null)}<br>333—–3–&lt;NSThread: 0x60000007b380&gt;{number = 5, name = (null)}</p></blockquote><ul><li>打印信息显示，除了主线程，又开启了4个线程，任务是交替执行。<br>所有任务是在打印的begin和end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始异步执行。</li></ul><h6 id="串行队列-同步执行"><a href="#串行队列-同步执行" class="headerlink" title="串行队列+同步执行"></a>串行队列+同步执行</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func syncSerial() -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">        print(&quot;syncSerial---begin&quot;)</span><br><span class="line">        </span><br><span class="line">        let queue = DispatchQueue(label: &quot;queue&quot;)</span><br><span class="line">        </span><br><span class="line">        queue.sync &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;111-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.sync &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;222-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.sync &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;333-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        print(&quot;syncSerial---end&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void) syncSerial&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;111------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;222------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;333------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>syncSerial—begin<br>111—–1–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>111—–2–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>111—–3–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>222—–1–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>222—–2–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>222—–3–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>333—–1–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>333—–2–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>333—–3–&lt;NSThread: 0x60800006b7c0&gt;{number = 1, name = main}<br>syncSerial—end</p></blockquote><ul><li>打印信息显示，所有任务在主线程中执行的，没有开启新线程。而且串行逐一执行。所有任务都在打印的begin和end之间，这说明任务是添加到队列中马上执行的。</li></ul><h6 id="串行队列-异步执行"><a href="#串行队列-异步执行" class="headerlink" title="串行队列+异步执行"></a>串行队列+异步执行</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func asyncSerial() -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">        print(&quot;asyncSerial---begin&quot;)</span><br><span class="line">        </span><br><span class="line">        let queue = DispatchQueue(label: &quot;queue&quot;)</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;111-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;222-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;333-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        print(&quot;asyncSerial---end&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void) asyncSerial&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>asyncSerial—begin<br>asyncSerial—end<br>111—–1–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>111—–2–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>111—–3–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>222—–1–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>222—–2–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>222—–3–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>333—–1–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>333—–2–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}<br>333—–3–&lt;NSThread: 0x60000007b280&gt;{number = 6, name = (null)}</p></blockquote><ul><li>打印信息显示，开启了新线程，但是任务串行逐一执行。所有任务是在打印的begin和end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li></ul><h6 id="主队列-同步执行"><a href="#主队列-同步执行" class="headerlink" title="主队列+同步执行"></a>主队列+同步执行</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func asyncMain() -&gt; Void &#123;</span><br><span class="line">       </span><br><span class="line">       print(&quot;asyncMain---begin&quot;)</span><br><span class="line">       </span><br><span class="line">       let queue = DispatchQueue.main</span><br><span class="line">       </span><br><span class="line">       queue.async &#123;</span><br><span class="line">           for i in 1...3 &#123;</span><br><span class="line">               print(&quot;111-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       queue.async &#123;</span><br><span class="line">           for i in 1...3 &#123;</span><br><span class="line">               print(&quot;222-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       queue.async &#123;</span><br><span class="line">           for i in 1...3 &#123;</span><br><span class="line">               print(&quot;333-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       print(&quot;asyncMain---end&quot;)</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)syncMain&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>syncMain—begin<br>(lldb) </p></blockquote><ul><li>这时候打印了begin后抛出了crash，当任务加入主线程。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在正在处理syncMain方法，所以任务需要等<code>syncMain</code>执行完才能执行。而<code>syncMain</code>执行到第一个任务的时候，又要等第一个任务执行完才能继续执行。这样互相等待，就造成了死锁，所以我们的任务执行不了，而且end也没有打印。<h6 id="既然主队列同步执行不成立，我们试一下创建一个并行队列异步执行主队列同步任务"><a href="#既然主队列同步执行不成立，我们试一下创建一个并行队列异步执行主队列同步任务" class="headerlink" title="既然主队列同步执行不成立，我们试一下创建一个并行队列异步执行主队列同步任务"></a>既然主队列同步执行不成立，我们试一下创建一个并行队列异步执行主队列同步任务</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [self syncMain];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>2017-03-28 18:43:14.463 GCDDemo[32024:3326849] syncMain—begin<br>2017-03-28 18:43:14.481 GCDDemo[32024:3326735] 1——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.481 GCDDemo[32024:3326735] 1——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.482 GCDDemo[32024:3326735] 1——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.482 GCDDemo[32024:3326735] 2——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.482 GCDDemo[32024:3326735] 2——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.483 GCDDemo[32024:3326735] 2——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.483 GCDDemo[32024:3326735] 3——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.483 GCDDemo[32024:3326735] 3——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.483 GCDDemo[32024:3326735] 3——&lt;NSThread: 0x608000065c00&gt;{number = 1, name = main}<br>2017-03-28 18:43:14.483 GCDDemo[32024:3326849] syncMain—end</p></blockquote><ul><li>通过打印信息可以发现，虽然是异步可以开启线程，但是还是在主线程串行执行了任务，所有任务是在打印的begin和end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li></ul><h6 id="主队列-异步执行"><a href="#主队列-异步执行" class="headerlink" title="主队列+异步执行"></a>主队列+异步执行</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func asyncMain() -&gt; Void &#123;</span><br><span class="line">        </span><br><span class="line">        print(&quot;asyncMain---begin&quot;)</span><br><span class="line">        </span><br><span class="line">        let queue = DispatchQueue.main</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;111-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;222-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 1...3 &#123;</span><br><span class="line">                print(&quot;333-----\(i)--\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        print(&quot;asyncMain---end&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)asyncMain&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;111------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;222------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;333------%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>asyncMain—begin<br>asyncMain—end<br>111—–1–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>111—–2–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>111—–3–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>222—–1–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>222—–2–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>222—–3–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>333—–1–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>333—–2–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}<br>333—–3–&lt;NSThread: 0x600000066180&gt;{number = 1, name = main}</p></blockquote><ul><li>所有任务都在主线程中，虽然是异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中逐一执行。所有任务是在打印的begin和end之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li></ul><h2 id="4-线程间通信"><a href="#4-线程间通信" class="headerlink" title="4.线程间通信"></a>4.线程间通信</h2><p>在开发过程中我们可能把一些耗时的操作放在其他线程执行，但是完成之后需要刷新UI，这时候就要返回主线程刷新UI<br><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">button.setTitle(&quot;-----&quot;, for: .normal)</span><br><span class="line">        let queue = DispatchQueue.global(qos: .default)</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            for i in 0..&lt;3&#123;</span><br><span class="line">                print(&quot;connection\(i)-------\(Thread.current)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            DispatchQueue.main.async &#123;</span><br><span class="line">                self.button.setTitle(&quot;线程间通信&quot;, for: .normal)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[_button setTitle:@&quot;-----&quot; forState:(UIControlStateNormal)];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">            NSLog(@&quot;connection%d------%@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [_button setTitle:@&quot;线程间通信&quot; forState:(UIControlStateNormal)];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>connection0——-&lt;NSThread: 0x608000260940&gt;{number = 3, name = (null)}<br>connection1——-&lt;NSThread: 0x608000260940&gt;{number = 3, name = (null)}<br>connection2——-&lt;NSThread: 0x608000260940&gt;{number = 3, name = (null)}<br>connection——-&lt;NSThread: 0x600000067980&gt;{number = 1, name = main}</p></blockquote><ul><li>打印看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。</li></ul><h6 id="线程障碍方法"><a href="#线程障碍方法" class="headerlink" title="线程障碍方法"></a>线程障碍方法</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;begin&quot;)</span><br><span class="line">        let queue = DispatchQueue(label: &quot;queue&quot;, attributes: .concurrent)</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;111-----\(Thread.current)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;222-----\(Thread.current)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async(group: nil, qos: .default, flags: .barrier) &#123; </span><br><span class="line">            print(&quot;barrier-----\(Thread.current)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;333-----\(Thread.current)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;444-----\(Thread.current)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;end&quot;)</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;111-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;222-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----barrier-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;333-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;444-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>begin<br>end<br>222—–&lt;NSThread: 0x600000278f00&gt;{number = 3, name = (null)}<br>111—–&lt;NSThread: 0x600000278f40&gt;{number = 4, name = (null)}<br>barrier—–&lt;NSThread: 0x600000278f40&gt;{number = 4, name = (null)}<br>333—–&lt;NSThread: 0x600000278f00&gt;{number = 3, name = (null)}<br>444—–&lt;NSThread: 0x600000278f00&gt;{number = 3, name = (null)}</p></blockquote><ul><li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于障碍一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。</li></ul><h6 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button.setTitle(&quot;延时&quot;, for: .normal)</span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; </span><br><span class="line">            self.button.setTitle(&quot;线程间通信&quot;, for: .normal)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[_button setTitle:@&quot;延时&quot; forState:(UIControlStateNormal)];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [_button setTitle:@&quot;线程间通信&quot; forState:(UIControlStateNormal)];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><ul><li>当我们需要延迟执行一段代码时，就需要用到GCD的after方法。</li></ul><h6 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h6><p><code>Swift</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let group = DispatchGroup()</span><br><span class="line">       let queue1 = DispatchQueue(label: &quot;queue1&quot;)</span><br><span class="line">       queue1.async(group: group) &#123;</span><br><span class="line">           for i in 1...10 &#123;</span><br><span class="line">               print(&quot;111-----\(i)-----\(Thread.current)&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">           print(&quot;111:\(Thread.current)&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">       let queue2 = DispatchQueue(label:&quot;queue2&quot;)</span><br><span class="line">       group.notify(queue: queue2) &#123;</span><br><span class="line">           queue2.async &#123;</span><br><span class="line">               for i in 1...10 &#123;</span><br><span class="line">                   print(&quot;222-----\(i)-----\(Thread.current)&quot;)</span><br><span class="line">               &#125;</span><br><span class="line">               print(&quot;222:\(Thread.current)&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p><code>OC</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            NSLog(@&quot;111-----%d-----%@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;queue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_group_notify(group, queue2, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            NSLog(@&quot;222-----%d-----%@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>111—–1—–&lt;NSThread: 0x608000077880&gt;{number = 5, name = (null)}<br>111—–2—–&lt;NSThread: 0x608000077880&gt;{number = 5, name = (null)}<br>111—–3—–&lt;NSThread: 0x608000077880&gt;{number = 5, name = (null)}<br>111:&lt;NSThread: 0x608000077880&gt;{number = 5, name = (null)}<br>222—–1—–&lt;NSThread: 0x60000006fac0&gt;{number = 6, name = (null)}<br>222—–2—–&lt;NSThread: 0x60000006fac0&gt;{number = 6, name = (null)}<br>222—–3—–&lt;NSThread: 0x60000006fac0&gt;{number = 6, name = (null)}<br>222:&lt;NSThread: 0x60000006fac0&gt;{number = 6, name = (null)}</p></blockquote><ul><li>我们经常也会有这样一种需要，一个任务必须在另外一个任务完成后再进行操作，又或者在其他线程中完成任务后，再回到主线程中去刷新UI页面。这时候可以使用队列组来逐一执行任务。</li></ul><h5 id="demo先呈上，之后继续更新"><a href="#demo先呈上，之后继续更新" class="headerlink" title="demo先呈上，之后继续更新"></a><a href="https://github.com/2016321/GCD_Demo" target="_blank" rel="noopener">demo</a>先呈上，之后继续更新</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-GCD简介&quot;&gt;&lt;a href=&quot;#1-GCD简介&quot; class=&quot;headerlink&quot; title=&quot;1. GCD简介&quot;&gt;&lt;/a&gt;1. GCD简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;什么是GCD呢？我们先来看看百度百
      
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="OC" scheme="http://yoursite.com/tags/OC/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>KVC 遇到的一些问题 O.o?</title>
    <link href="http://yoursite.com/2017/02/09/KVC-%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98-O-o/"/>
    <id>http://yoursite.com/2017/02/09/KVC-遇到的一些问题-O-o/</id>
    <published>2017-02-09T10:54:06.000Z</published>
    <updated>2018-07-02T10:42:26.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WTF-O-o"><a href="#WTF-O-o" class="headerlink" title="WTF O.o?"></a>WTF O.o?</h3><h5 id="今天在自己封装控件时候发现一个问题，当我使用KVC和-keyPath发生了一个crash"><a href="#今天在自己封装控件时候发现一个问题，当我使用KVC和-keyPath发生了一个crash" class="headerlink" title="今天在自己封装控件时候发现一个问题，当我使用KVC和#keyPath发生了一个crash"></a>今天在自己封装控件时候发现一个问题，当我使用KVC和#keyPath发生了一个crash</h5><a id="more"></a><p><img src="https://s6.postimg.cc/cvzjt21sx/2353844-5a45c7b8c229a1fe.png" alt="Paste_Image.png"></p><p><img src="https://s6.postimg.cc/40ypik05t/2353844-164563491b9a1394.png" alt="Paste_Image.png"></p><p><img src="https://s6.postimg.cc/cj85mvr8x/2353844-00a451a5805a2e26.png" alt="Paste_Image.png"></p><h5 id="花生了什么？！！！"><a href="#花生了什么？！！！" class="headerlink" title="花生了什么？！！！"></a>花生了什么？！！！</h5><h5 id="然后我就用runtime打印了一下属性列表"><a href="#然后我就用runtime打印了一下属性列表" class="headerlink" title="然后我就用runtime打印了一下属性列表"></a>然后我就用runtime打印了一下属性列表</h5><p><img src="https://s6.postimg.cc/uysmkad35/2353844-4e530c64e8345545.png" alt="Paste_Image.png"></p><h5 id="发现根本就没有这个属性，拉特纳爸爸？！！！什么情况？！！！说走就走，留了一堆bug！！！"><a href="#发现根本就没有这个属性，拉特纳爸爸？！！！什么情况？！！！说走就走，留了一堆bug！！！" class="headerlink" title="发现根本就没有这个属性，拉特纳爸爸？！！！什么情况？！！！说走就走，留了一堆bug！！！"></a>发现根本就没有这个属性，拉特纳爸爸？！！！什么情况？！！！说走就走，留了一堆bug！！！</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;WTF-O-o&quot;&gt;&lt;a href=&quot;#WTF-O-o&quot; class=&quot;headerlink&quot; title=&quot;WTF O.o?&quot;&gt;&lt;/a&gt;WTF O.o?&lt;/h3&gt;&lt;h5 id=&quot;今天在自己封装控件时候发现一个问题，当我使用KVC和-keyPath发生了一个crash&quot;&gt;&lt;a href=&quot;#今天在自己封装控件时候发现一个问题，当我使用KVC和-keyPath发生了一个crash&quot; class=&quot;headerlink&quot; title=&quot;今天在自己封装控件时候发现一个问题，当我使用KVC和#keyPath发生了一个crash&quot;&gt;&lt;/a&gt;今天在自己封装控件时候发现一个问题，当我使用KVC和#keyPath发生了一个crash&lt;/h5&gt;
    
    </summary>
    
      <category term="Mobile" scheme="http://yoursite.com/categories/Mobile/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
</feed>
